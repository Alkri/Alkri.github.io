<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Python3]关于桌面托盘和气泡QwQ]]></title>
    <url>%2Farticles%2FPython3-%E5%85%B3%E4%BA%8E%E6%A1%8C%E9%9D%A2%E6%89%98%E7%9B%98%E5%92%8C%E6%B0%94%E6%B3%A1QwQ%2F</url>
    <content type="text"><![CDATA[最近写个工程的时候踩的大坑QAQ。。。 前言看了一下上次的更新时间，2018-11-06。。。 这个Blog也算是荒了一阵子了（期末考啊我也很无奈啊。。。 然后在我的好友mnihyc骚扰劝说下，打算继续更新Blog。（虽然他的Blog这段时间内崩了一回，数据都没了 所以我也没啥好写的，就水一篇博客吧，嘻嘻。 正文关于这个Python的桌面托盘上的事，某度上基本没啥资料。。。 其实我主要是因为Win10的气泡提醒看起来还不错，就懒得自己写个窗口了。 然后我就一直找气泡提醒。。。。。。结果找到了下面两个（可用的 1. 这是socrates大佬的，2012年更新的（还tm要依赖这个模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383#!/usr/bin/env python# -*- coding: utf-8 -*- #gtkPopupNotify.py## Copyright 2009 Daniel Woodhouse # modified by NickCis 2010 http://github.com/NickCis/gtkPopupNotify# Modifications:# Added: * Corner support (notifications can be displayed in all corners# * Use of gtk Stock items or pixbuf to render images in notifications# * Posibility of use fixed height# * Posibility of use image as background# * Not displaying over Windows taskbar(taken from emesene gpl v3)# * y separation.# * font description options# * Callbacks For left, middle and right click##This program is free software: you can redistribute it and/or modify#it under the terms of the GNU Lesser General Public License as published by#the Free Software Foundation, either version 3 of the License, or#(at your option) any later version.##This program is distributed in the hope that it will be useful,#but WITHOUT ANY WARRANTY; without even the implied warranty of#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the#GNU Lesser General Public License for more details.##You should have received a copy of the GNU Lesser General Public License#along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;. import osimport gtkimport pangoimport gobject # This code is used only on Windows to get the location on the taskbar# Taken from emesene Notifications (Gpl v3)taskbarOffsety = 0taskbarOffsetx = 0if os.name == "nt": import ctypes from ctypes.wintypes import RECT, DWORD user = ctypes.windll.user32 MONITORINFOF_PRIMARY = 1 HMONITOR = 1 class MONITORINFO(ctypes.Structure): _fields_ = [ ('cbSize', DWORD), ('rcMonitor', RECT), ('rcWork', RECT), ('dwFlags', DWORD) ] taskbarSide = "bottom" taskbarOffset = 30 info = MONITORINFO() info.cbSize = ctypes.sizeof(info) info.dwFlags = MONITORINFOF_PRIMARY user.GetMonitorInfoW(HMONITOR, ctypes.byref(info)) if info.rcMonitor.bottom != info.rcWork.bottom: taskbarOffsety = info.rcMonitor.bottom - info.rcWork.bottom if info.rcMonitor.top != info.rcWork.top: taskbarSide = "top" taskbarOffsety = info.rcWork.top - info.rcMonitor.top if info.rcMonitor.left != info.rcWork.left: taskbarSide = "left" taskbarOffsetx = info.rcWork.left - info.rcMonitor.left if info.rcMonitor.right != info.rcWork.right: taskbarSide = "right" taskbarOffsetx = info.rcMonitor.right - info.rcWork.right class NotificationStack: def __init__(self, size_x=300, size_y=-1, timeout=5, corner=(False, False), sep_y=0): """ Create a new notification stack. The recommended way to create Popup instances. Parameters: `size_x` : The desired width of the notifications. `size_y` : The desired minimum height of the notifications. If it isn't set, or setted to None, the size will automatically adjust `timeout` : Popup instance will disappear after this timeout if there is no human intervention. This can be overridden temporarily by passing a new timout to the new_popup method. `coner` : 2 Value tuple: (true if left, True if top) `sep_y` : y distance to separate notifications from each other """ self.size_x = size_x self.size_y = -1 if (size_y == None): pass else: size_y self.timeout = timeout self.corner = corner self.sep_y = sep_y """ Other parameters: These will take effect for every popup created after the change. `edge_offset_y` : distance from the bottom of the screen and the bottom of the stack. `edge_offset_x` : distance from the right edge of the screen and the side of the stack. `max_popups` : The maximum number of popups to be shown on the screen at one time. `bg_color` : if None default is used (usually grey). set with a gtk.gdk.Color. `bg_pixmap` : Pixmap to use as background of notification. You can set a gtk.gdk.Pixmap or a path to a image. If none, the color background will be displayed. `bg_mask` : If a gtk.gdk.pixmap is specified under bg_pixmap, the mask of the pixmap has to be setted here. `fg_color` : if None default is used (usually black). set with a gtk.gdk.Color. `show_timeout` : if True, a countdown till destruction will be displayed. `close_but` : if True, the close button will be displayed. `fontdesc` : a 3 value Tuple containing the pango.FontDescriptions of the Header, message and counter (in that order). If a string is suplyed, it will be used for the 3 the same FontDescription. http://doc.stoq.com.br/devel/pygtk/class-pangofontdescription.html """ self.edge_offset_x = 0 self.edge_offset_y = 0 self.max_popups = 5 self.fg_color = None self.bg_color = None self.bg_pixmap = None self.bg_mask = None self.show_timeout = False self.close_but = True self.fontdesc = ("Sans Bold 14", "Sans 12", "Sans 10") self._notify_stack = [] self._offset = 0 def new_popup(self, title, message, image=None, leftCb=None, middleCb=None, rightCb=None): """Create a new Popup instance.""" if len(self._notify_stack) == self.max_popups: self._notify_stack[0].hide_notification() self._notify_stack.append(Popup(self, title, message, image, leftCb, middleCb, rightCb)) self._offset += self._notify_stack[-1].y def destroy_popup_cb(self, popup): self._notify_stack.remove(popup) #move popups down if required offset = 0 for note in self._notify_stack: offset = note.reposition(offset, self) self._offset = offset class Popup(gtk.Window): def __init__(self, stack, title, message, image, leftCb, middleCb, rightCb): gtk.Window.__init__(self, type=gtk.WINDOW_POPUP) self.leftclickCB = leftCb self.middleclickCB = middleCb self.rightclickCB = rightCb self.set_size_request(stack.size_x, stack.size_y) self.set_decorated(False) self.set_deletable(False) self.set_property("skip-pager-hint", True) self.set_property("skip-taskbar-hint", True) self.connect("enter-notify-event", self.on_hover, True) self.connect("leave-notify-event", self.on_hover, False) self.set_opacity(0.2) self.destroy_cb = stack.destroy_popup_cb if type(stack.fontdesc) == tuple or type(stack.fontdesc) == list: fontH, fontM, fontC = stack.fontdesc else: fontH = fontM = fontC = stack.fontdesc main_box = gtk.VBox() header_box = gtk.HBox() self.header = gtk.Label() self.header.set_markup("&lt;b&gt;%s&lt;/b&gt;" % title) self.header.set_padding(3, 3) self.header.set_alignment(0, 0) try: self.header.modify_font(pango.FontDescription(fontH)) except Exception, e: print e header_box.pack_start(self.header, True, True, 5) if stack.close_but: close_button = gtk.Image() close_button.set_from_stock(gtk.STOCK_CANCEL, gtk.ICON_SIZE_BUTTON) close_button.set_padding(3, 3) close_window = gtk.EventBox() close_window.set_visible_window(False) close_window.connect("button-press-event", self.hide_notification) close_window.add(close_button) header_box.pack_end(close_window, False, False) main_box.pack_start(header_box) body_box = gtk.HBox() if image is not None: self.image = gtk.Image() self.image.set_size_request(70, 70) self.image.set_alignment(0, 0) if image in gtk.stock_list_ids(): self.image.set_from_stock(image, gtk.ICON_SIZE_DIALOG) elif type(image) == gtk.gdk.Pixbuf: self.image.set_from_pixbuf(image) else: self.image.set_from_file(image) body_box.pack_start(self.image, False, False, 5) self.message = gtk.Label() self.message.set_property("wrap", True) self.message.set_size_request(stack.size_x - 90, -1) self.message.set_alignment(0, 0) self.message.set_padding(5, 10) self.message.set_markup(message) try: self.message.modify_font(pango.FontDescription(fontM)) except Exception, e: print e self.counter = gtk.Label() self.counter.set_alignment(1, 1) self.counter.set_padding(3, 3) try: self.counter.modify_font(pango.FontDescription(fontC)) except Exception, e: print e self.timeout = stack.timeout body_box.pack_start(self.message, True, False, 5) body_box.pack_end(self.counter, False, False, 5) main_box.pack_start(body_box) eventbox = gtk.EventBox() eventbox.set_property('visible-window', False) eventbox.set_events(gtk.gdk.BUTTON_PRESS_MASK) eventbox.connect("button_press_event", self.onClick) eventbox.add(main_box) self.add(eventbox) if stack.bg_pixmap is not None: if not type(stack.bg_pixmap) == gtk.gdk.Pixmap: stack.bg_pixmap, stack.bg_mask = gtk.gdk.pixbuf_new_from_file(stack.bg_pixmap).render_pixmap_and_mask() self.set_app_paintable(True) self.connect_after("realize", self.callbackrealize, stack.bg_pixmap, stack.bg_mask) elif stack.bg_color is not None: self.modify_bg(gtk.STATE_NORMAL, stack.bg_color) if stack.fg_color is not None: self.message.modify_fg(gtk.STATE_NORMAL, stack.fg_color) self.header.modify_fg(gtk.STATE_NORMAL, stack.fg_color) self.counter.modify_fg(gtk.STATE_NORMAL, stack.fg_color) self.show_timeout = stack.show_timeout self.hover = False self.show_all() self.x, self.y = self.size_request() #Not displaying over windows bar if os.name == 'nt': if stack.corner[0] and taskbarSide == "left": stack.edge_offset_x += taskbarOffsetx elif not stack.corner[0] and taskbarSide == 'right': stack.edge_offset_x += taskbarOffsetx if stack.corner[1] and taskbarSide == "top": stack.edge_offset_x += taskbarOffsety elif not stack.corner[1] and taskbarSide == 'bottom': stack.edge_offset_x += taskbarOffsety if stack.corner[0]: posx = stack.edge_offset_x else: posx = gtk.gdk.screen_width() - self.x - stack.edge_offset_x sep_y = 0 if (stack._offset == 0): pass else: stack.sep_y self.y += sep_y if stack.corner[1]: posy = stack._offset + stack.edge_offset_y + sep_y else: posy = gtk.gdk.screen_height()- self.y - stack._offset - stack.edge_offset_y self.move(posx, posy) self.fade_in_timer = gobject.timeout_add(100, self.fade_in) def reposition(self, offset, stack): """Move the notification window down, when an older notification is removed""" if stack.corner[0]: posx = stack.edge_offset_x else: posx = gtk.gdk.screen_width() - self.x - stack.edge_offset_x if stack.corner[1]: posy = offset + stack.edge_offset_y new_offset = self.y + offset else: new_offset = self.y + offset posy = gtk.gdk.screen_height() - new_offset - stack.edge_offset_y + stack.sep_y self.move(posx, posy) return new_offset def fade_in(self): opacity = self.get_opacity() opacity += 0.15 if opacity &gt;= 1: self.wait_timer = gobject.timeout_add(1000, self.wait) return False self.set_opacity(opacity) return True def wait(self): if not self.hover: self.timeout -= 1 if self.show_timeout: self.counter.set_markup(str("&lt;b&gt;%s&lt;/b&gt;" % self.timeout)) if self.timeout == 0: self.fade_out_timer = gobject.timeout_add(100, self.fade_out) return False return True def fade_out(self): opacity = self.get_opacity() opacity -= 0.10 if opacity &lt;= 0: self.in_progress = False self.hide_notification() return False self.set_opacity(opacity) return True def on_hover(self, window, event, hover): """Starts/Stops the notification timer on a mouse in/out event""" self.hover = hover def hide_notification(self, *args): """Destroys the notification and tells the stack to move the remaining notification windows""" for timer in ("fade_in_timer", "fade_out_timer", "wait_timer"): if hasattr(self, timer): gobject.source_remove(getattr(self, timer)) self.destroy() self.destroy_cb(self) def callbackrealize(self, widget, pixmap, mask=False): #width, height = pixmap.get_size() #self.resize(width, height) if mask is not False: self.shape_combine_mask(mask, 0, 0) self.window.set_back_pixmap(pixmap, False) return True def onClick(self, widget, event): if event.button == 1 and self.leftclickCB != None: self.leftclickCB() self.hide_notification() if event.button == 2 and self.middleclickCB != None: self.middleclickCB() self.hide_notification() if event.button == 3 and self.rightclickCB != None: self.rightclickCB() self.hide_notification() if __name__ == "__main__": #example usage def notify_factory(): color = ("green", "blue") image = "logo1_64.png" notifier.bg_color = gtk.gdk.Color(color[0]) notifier.fg_color = gtk.gdk.Color(color[1]) notifier.show_timeout = True notifier.edge_offset_x = 20 notifier.edge_offset_y = 30 notifier.new_popup("Windows上的泡泡提示", "NND，比Linux下复杂多了，效果还不怎么样", image=image) return True def gtk_main_quit(): print "quitting" gtk.main_quit() notifier = NotificationStack(timeout=1) gobject.timeout_add(4000, notify_factory) gobject.timeout_add(8000, gtk_main_quit) gtk.main() 这个我不知道能不能用（反正这个不是Python3的 不过好像用的也不是Win10下原汁原味的提示。。。 2.emmm我不知道扔哪里去了至少这个可以用，是利用Python3调用winAPI 然后瞎搞搞。。。。（反正我是觉得太麻烦了啊 解决方案最后，我想到了我的wxPython是不是有这样的功能 然后百度了一下 找到了这个j*玩意，居然是wxPython+winAPI的？？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import wximport win32gui import win32con import time from winxpgui import * class SparkTaskBarIcon(wx.TaskBarIcon): TBMENU_RESTORE = wx.NewId() TBMENU_CLOSE = wx.NewId() TBMENU_CHANGE = wx.NewId() TBMENU_REMOVE = wx.NewId() def __init__(self, frame,picon,icon): wx.TaskBarIcon.__init__(self) self.frame = frame # Set the image #icon = self.MakeIcon(images.WXPdemo.GetImage()) wc = win32gui.WNDCLASS() hinst = wc.hInstance = win32gui.GetModuleHandle(None) icon_flags = win32con.LR_LOADFROMFILE | win32con.LR_DEFAULTSIZE hicon = LoadImage(hinst, icon, win32con.IMAGE_ICON, 0, 0, icon_flags) self.SetIcon(picon, "Spark") self.imgidx = 1 # bind some events self.Bind(wx.EVT_TASKBAR_LEFT_DCLICK, self.OnTaskBarActivate) self.Bind(wx.EVT_MENU, self.OnTaskBarActivate, id=self.TBMENU_RESTORE) self.Bind(wx.EVT_MENU, self.OnTaskBarClose, id=self.TBMENU_CLOSE) #self.Bind(wx.EVT_MENU, self.OnTaskBarChange, id=self.TBMENU_CHANGE) self.Bind(wx.EVT_MENU, self.OnTaskBarRemove, id=self.TBMENU_REMOVE) #气泡提示注册win的窗口消息 wc.lpszClassName = "Spark" wc.lpfnWndProc = &#123;win32con.WM_DESTROY: self.OnDestroy,&#125; classAtom = win32gui.RegisterClass(wc) style = win32con.WS_OVERLAPPED | win32con.WS_SYSMENU self.hwnd = win32gui.CreateWindow( classAtom, "Spark", style, 0, 0, win32con.CW_USEDEFAULT, win32con.CW_USEDEFAULT, 0, 0, hinst, None) #hicon = win32gui.LoadIcon(0, win32con.IDI_APPLICATION) nid = (self.hwnd, 0, win32gui.NIF_ICON, win32con.WM_USER+20, hicon, "Spark") win32gui.Shell_NotifyIcon(win32gui.NIM_ADD, nid) def OnDestroy(self, hwnd, msg, wparam, lparam): nid = (self.hwnd, 0) win32gui.Shell_NotifyIcon(win32gui.NIM_DELETE, nid) win32gui.PostQuitMessage(0) # Terminate the app. def showMsg(self, title, msg): # 原作者使用Shell_NotifyIconA方法代替包装后的Shell_NotifyIcon方法 # 据称是不能win32gui structure, 我稀里糊涂搞出来了. # 具体对比原代码. nid = (self.hwnd, # 句柄 0, # 托盘图标ID win32gui.NIF_INFO, # 标识 0, # 回调消息ID 0, # 托盘图标句柄 "Spark Message", # 图标字符串 msg, # 气球提示字符串 5, # 提示的显示时间 title, # 提示标题 win32gui.NIIF_INFO # 提示用到的图标 ) win32gui.Shell_NotifyIcon(win32gui.NIM_MODIFY, nid) def CreatePopupMenu(self): """ This method is called by the base class when it needs to popup the menu for the default EVT_RIGHT_DOWN event. Just create the menu how you want it and return it from this function, the base class takes care of the rest. """ menu = wx.Menu() menu.Append(self.TBMENU_RESTORE, "Restore spark") menu.Append(self.TBMENU_CLOSE, "Close spark") menu.AppendSeparator() #menu.Append(self.TBMENU_CHANGE, "Change the TB Icon") menu.Append(self.TBMENU_REMOVE, "Remove Spark") return menu #def MakeIcon(self, img): #""" #The various platforms have different requirements for the #icon size... #""" #if "wxMSW" in wx.PlatformInfo: #img = img.Scale(16, 16) #elif "wxGTK" in wx.PlatformInfo: #img = img.Scale(22, 22) ## wxMac can be any size upto 128x128, so leave the source img alone.... #icon = wx.IconFromBitmap(img.ConvertToBitmap() ) #return icon def OnTaskBarActivate(self, evt): if self.frame.IsIconized(): self.frame.Iconize(False) if not self.frame.IsShown(): self.frame.Show(True) self.frame.Raise() def OnTaskBarClose(self, evt): wx.CallAfter(self.frame.OnClose) #def OnTaskBarChange(self, evt): #names = [ "WXPdemo", "Mondrian", "Pencil", "Carrot" ] #name = names[self.imgidx] #eImg = getattr(images, name) #self.imgidx += 1 #if self.imgidx &gt;= len(names): #self.imgidx = 0 #icon = self.MakeIcon(eImg.Image) #self.SetIcon(icon, "This is a new icon: " + name) def OnTaskBarRemove(self, evt): self.RemoveIcon() 不过至少是实现了这一功能 但是英明的我怎么会满足于此呢？（我tm写个气泡提示就要这么长真的难受。。。。 于是我开开心心地Google了一下，居然还是没有？？？？ 但是，我在一篇用winAPI解决的Blog里看到了这个 有一个小需求希望在wx下建立的托盘区图标上显示气球消息,很尴尬的是wx.TaskBarIcon不像wx.Window等有GetHandle方法,无法直接获得句柄.解决的办法1.自己重写TaskBarIcon… 2.直接遍历找到句柄(更通用麻烦些).据说wxpython在2.9后会加一个wx.NotificationMessage方法,但是2.9….哪年月有动静呢? 哇这个wx.NotificationMessage是个什么东西 然后看了看wxPython官网，都TM4.0.4了，你这什么LJ版本。 于是我终于在官方文档里找到了这个东西。。。 （居然还是wx.adv模块里的。。。 调用方法简单来写就是 1wx.adv.NotificationMessage(title,message).Show() 至少用一句话代替了上面那坨100+行的winAPI 具体方法的话请Click 后记不过这个东西还是不能完美的实现这个功能，他在通知的时候就会在托盘里加一个Python的图标。。。 这个东西我也没啥好办法，将就用着吧，如果你有什么方法可以解决（别TM说winAPI），请email我！ （这个东西耗了我1个小时，我……QAQ]]></content>
      <tags>
        <tag>Python3</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2018模拟]挑战书]]></title>
    <url>%2Farticles%2FNOIP2018%E6%A8%A1%E6%8B%9F-%E6%8C%91%E6%88%98%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[Description小 $E$ 是一位实力强大的 $OIer$，经常在各类比赛中随手 $AK$ 虐场。然而她最近秒题时遇到了一道需要她思考 $15$ 秒才能做出的题目，整整花了 $15$ 倍于其他题目的时间。她认为这个问题十分有意思，并且对其进行了一些拓展和修改以后抛给了你。你能接受小 $E$ 的挑战吗？ 设 $p_i$ 表示非负整数 $p$ 的二进制表示中在项 $2^i$ 前的系数，对于非负整数 $p$,$q$ ，可以定义二元运算 $xnor$（同或）为：$p\;xnor\;q=\sum^m_{i=0}{((p_i\wedge q_i)\vee(\neg(p_i\vee q_i)))\times2^i}$（在这里我们认为布尔表达式的值 $false$ 或 $true$ 能够直接对应于整数 $0$ 或 $1$ 并参与算术运算，反之亦然；其中 $M$ 为常数，本题中M 的取值为 $31$）。 给定一个长度为 $n$ 的非负整数序列 $a$ ，在序列的每个位置上有非负整数权值 $w_i$ ，现在希望实现对该序列的以下操作： 给 定 区 间 $[l,r]$ 和 非 负 整 数 $k$ ， 查 询。 $(\sum_{i=l}^r{a_i\times w’(i))xnor(\sum_{i=l}^r{a_i})}$ 其中$w’(i)=\begin{cases}w_i,if \space w_i \le k \\ 0,if \space w_i&gt;k \end{cases}$。 给定正整数 $p$ 和非负整数 $k$ ，将 $a_p$ 的值修改为 $k$ 。 给定正整数 $p$ 和非负整数 $k$ ，将 $w_p$ 的值修改为 $k$ 。 如果你不认识题目描述中的某些符号，可参见Hint部分。 Input Format输入的第 $1$ 行包含两个整数 $n$,$q$ ，$n$ 表示序列长度，$q$ 表示操作次数。 接下来 $1$ 行，包含 $n$ 个整数，其中第 $i$ 个表示 $a_i$ 。 接下来 $1$ 行，包含 $n$ 个整数，其中第 $i$ 个表示 $w_i$ 。 接下来 $q$ 行，每行包含 $4$ 个或 $3$ 个整数，其中第 $1$ 个整数表示操作类型（见题目描述）。 对于第 $1$ 种操作，接下来 $3$ 个整数依次表示 $l$,$r$,$k$ ；对于第 $2$ 或第 $3$ 种操作，接下来 $2$ 个整数依次表示 $p$,$k$ 。 Output Format对于每个第 $1$ 种操作输出一行一个整数，表示答案。 Input Sample1234567891011121310 1013 15 23 45 21 23 14 26 35 4412 32 15 47 15 32 12 47 32 321 2 8 172 4 261 1 6 473 9 62 9 41 1 7 53 7 62 7 23 3 61 4 9 6 Output Sample12344294966372429496401642949671604294967229 Hint【样例 $1$ 说明】 对于第 $1$ 次询问，$k=17$ ，此时在 $[2,8]$ 区间内第 $3$、第 $5$ 和第 $7$ 位置上的 $w_i\le17$ 。因此答案为$(a_3\times w_3+a_5\times w_5+a_7\times w_7)xnor(\sum_{i=1}^8{a_i})$。按照定义式计算即可得上式的值。 对于第 $3$ 次询问，此时序列上的权值为 $w=\{12,32,15,47,15,32,12,47,6,32\}$。$k=5$，但不存在 $w_i\le5$ 的位置，因此答案为 $0\;xnor(\sum_{i=1}^7{a_i})$。 【数据范围与约定】 对于全部数据，有 $1\le n,q\le10^5$，$0\le a_i,w_i,k\le10^5$，$1\le l,r,p\le n$。下表中留空的位置代表该测试点在这一项目上没有特殊约定。 $\wedge$表示逻辑与（即布尔代数中的与运算 $\text{and}$），$\neg$ 表示逻辑非（即布尔代数中的非运算 $not$）。 本题输入输出数据规模较大且时限较紧，请不要使用 $C$++ 风格 $I/O$ 操作并考虑使用 $I/O$ 优化。另请注意常数因子对程序效率的影响。标准程序未对常数因子进行专门优化，用时约为所给时间限制的一半。 题解题目怎么那么长啊喂，这样我的题解就短一点吧。 我们观察$xnor$操作，不难发现这个操作就相当于在无符号的$int$下的$not(x \space xor \space y)$ 然后我们考虑分块，这样就变成一个裸题了，$Ai$的和用树状数组维护。 注：编译环境下开启$O2$优化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;utility&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define Re register int#define LL long long#define uint unsigned int#define mp make_pairint N,Q,A[100005],W[100005],L[405],BlkSz,BlkNum;LL Sum[100005];std::pair&lt;int,LL&gt; Data[100005];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=x*10+ch-'0',ch=getchar(); var=w?-x:x;&#125;class TreeArr&#123; LL T[100005]; inline int lowbit(int x) &#123;return x&amp;-x;&#125;public: inline void AddNum(int pos,int x) &#123;for (;pos&lt;=N;pos+=lowbit(pos)) T[pos]+=x;&#125; inline LL Query(int pos) &#123; LL ret=0; for (;pos;pos-=lowbit(pos))ret+=T[pos]; return ret; &#125;&#125;Tr;inline uint xnor(LL a,LL b) &#123;return ~(uint)((a&amp;4294967295u)^(b&amp;4294967295u));&#125;inline int GetID(int x) &#123;return (x+BlkSz-1)/BlkSz;&#125;inline void ReBuild(int Ind)&#123; for (Re i=L[Ind]; i&lt;L[Ind+1]; ++i) Data[i]=std::mp(W[i],1LL*A[i]*W[i]); sort(Data+L[Ind],Data+L[Ind+1]); Sum[L[Ind]]=Data[L[Ind]].second; for (Re i=L[Ind]+1; i&lt;L[Ind+1]; ++i) Sum[i]=Sum[i-1]+Data[i].second;&#125;int main(int argc, char const *argv[])&#123; read(N),read(Q); BlkSz=sqrt(N),BlkNum=GetID(N); for (Re i=1; i&lt;=N; ++i) read(A[i]),Tr.AddNum(i,A[i]); for (Re i=1; i&lt;=N; ++i) read(W[i]); L[1]=1; L[BlkNum+1]=N+1; for (Re i=2; i&lt;=BlkNum; ++i) L[i]=L[i-1]+BlkSz; for (Re i=1; i&lt;=BlkNum; ++i) ReBuild(i); while (Q--) &#123; int opt,l,r,k; read(opt); switch (opt) &#123; case 1: &#123; LL S=0; read(l),read(r),read(k); if (GetID(l)!=GetID(r)) &#123; for (Re i=GetID(l)+1; i&lt;=GetID(r)-1; ++i) &#123; int x=L[i],y=L[i+1]-1; while (x&lt;=y) &#123; int mid=(x+y)&gt;&gt;1; if (Data[mid].first&gt;k) y=mid-1; else x=mid+1; &#125; if (y&gt;=L[i]) S+=Sum[y]; &#125; for (Re i=l; i&lt;L[GetID(l)+1]; ++i) if (W[i]&lt;=k) S+=1LL*A[i]*W[i]; for (Re i=L[GetID(r)]; i&lt;=r; ++i) if (W[i]&lt;=k) S+=1LL*A[i]*W[i]; &#125; else for (Re i=l; i&lt;=r; ++i) if (W[i]&lt;=k) S+=1LL*A[i]*W[i]; printf("%u\n",xnor(S,Tr.Query(r)-Tr.Query(l-1))); &#125; break; case 2: read(l),read(k),Tr.AddNum(l,k-A[l]); A[l]=k; ReBuild(GetID(l)); break; case 3: read(l),read(k),W[l]=k; ReBuild(GetID(l)); break; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2012]永无乡]]></title>
    <url>%2Farticles%2FHNOI2012-%E6%B0%B8%E6%97%A0%E4%B9%A1%2F</url>
    <content type="text"><![CDATA[Description有N个景点，编号从1到N。对所有景点，****给他们做了一个排名。 景点之间由道路连接。若一个景点a可以通过若干个节点到另一个景点b，则称这两个景点是连通的。 现在有两种操作： B x y表示在景点x与景点y之间修建一条道路。 Q x k表示询问当前与景点x连通的所有景点中，排名第k的景点是哪个，请你输出那个景点的编号。 Input Format第一行两个正整数N和M，分别表示景点的个数以及一开始存在的道路数。 接下来的一行有N个数，依次描述权王给景点1到景点N的排名（排名用1到N来表示）。 随后的M行每行两个正整数a和b，表示一开始就存在一条连接景点a与景点b的道路。 后面剩下的部分描述操作。 该部分的第一行是一个正整数q，表示一共有q个操作。 接下来的q行依次描述每个操作，操作的格式如上所述，以大写字母Q或B开始，后面跟两个不超过N的正整数。 Output Format对于每个Q x k操作都要依次输出一行，其中包含一个整数，表示所询问景点的编号。如果该景点不存在，则输出−1。 Sample Input12345678910115 14 3 2 5 11 27Q 3 2Q 2 1B 2 3B 1 5Q 2 1Q 2 4Q 2 3 Sample Output12345-12512 Hint对于30%的数据$N \le 1000,q \le 1000$ 对于60%的数据$N \le 10000,q≤10000$ 对于100%的数据$N \le 100000,m \le n,q \le 300000$ 题解这道题暴力分非常高（所以我只打了暴力(因为正解不会)） 我们可以考虑对每个景点都维护一棵线段树，记录和他在同一联通块内的景点所有的$Rank$值。 这样我们要维护$N$棵线段树，空间显然无法承受。 那么我们就考虑动态加点。 对于加边操作来说，我们只需要进行合并线段树的操作就可以快速地合并两个不同联通块内的$Rank$值。 接下来就是板子了。这样就AC了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define Re register intint tot,rt[3600005],ls[3600005],rs[3600005],Sum[3600005];int N,M,Q,fa[100005],Ind[100005];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=x*10+ch-'0',ch=getchar(); var=w?-x:x;&#125;int GetF(int x) &#123;return x==fa[x]?x:fa[x]=GetF(fa[x]);&#125;void Build(int &amp;id,int l,int r,int x)&#123; if (!id) id=++tot; ++Sum[id]; if (l==r) return; int mid=(l+r)&gt;&gt;1; if (x&lt;=mid) Build(ls[id],l,mid,x); else Build(rs[id],mid+1,r,x);&#125;int Query(int id,int l,int r,int x)&#123; if (l==r) return l; int mid=(l+r)&gt;&gt;1; if (x&lt;=Sum[ls[id]]) return Query(ls[id],l,mid,x); else return Query(rs[id],mid+1,r,x-Sum[ls[id]]);&#125;int Merge(int x,int y)&#123; if (!x) return y; if (!y) return x; ls[x]=Merge(ls[x],ls[y]); rs[x]=Merge(rs[x],rs[y]); Sum[x]=Sum[ls[x]]+Sum[rs[x]]; return x;&#125;int main(int argc, char const *argv[])&#123; scanf("%d%d\n",&amp;N,&amp;M); for (Re i=1,Rank; i&lt;=N; ++i) &#123; read(Rank); fa[i]=Ind[Rank]=i; //Ind记录下对应的景区号。 Build(rt[i],1,N,Rank); &#125; for (Re i=1,u,v; i&lt;=M; ++i) &#123; scanf("%d%d",&amp;u,&amp;v); u=GetF(u),v=GetF(v); if (u!=v) &#123;rt[u]=Merge(rt[u],rt[v]); fa[v]=u;&#125; //注意这里是将v并向u &#125; scanf("%d\n",&amp;Q); while (Q--) &#123; char opt; int x,k; scanf("%c%d%d\n",&amp;opt,&amp;x,&amp;k); if (opt=='B') &#123; x=GetF(x),k=GetF(k); if (x!=k) &#123;rt[x]=Merge(rt[x],rt[k]); fa[k]=x;&#125; //注意这里是将k并向x &#125; else printf("%d\n",Sum[rt[GetF(x)]]&lt;k?-1:Ind[Query(rt[GetF(x)],1,N,k)]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Luogu]跳楼机P3403]]></title>
    <url>%2Farticles%2FLuogu-%E8%B7%B3%E6%A5%BC%E6%9C%BAP3403%2F</url>
    <content type="text"><![CDATA[DescriptionSrwudi的家是一幢h层的摩天大楼。由于前来学习的蒟蒻越来越多，srwudi改造了一个跳楼机，使得访客可以更方便的上楼。 经过改造，srwudi的跳楼机可以采用以下四种方式移动： 向上移动x层； 向上移动y层； 向上移动z层； 回到第一层。 一个月黑风高的大中午，DJL来到了srwudi的家，现在他在srwudi家的第一层，碰巧跳楼机也在第一层。DJL想知道，他可以乘坐跳楼机前往的楼层数。 Input Format第一行一个整数h，表示摩天大楼的层数。 第二行三个正整数，分别表示题目中的x, y, z。 Output Format一行一个整数，表示DJL可以到达的楼层数。 Input Sample12154 7 9 Output Sample19 Hint可以到达的楼层有：1,5,8,9,10,12,13,14,15 $1 \le h \le 10^{18},1 \le x, y, z \le 10^5$ 题解很神奇的题目。。。一开始看到就想起了$NOIp2017D1T1$小凯的疑惑。 莫非这题是那题的变态加强版？然后也有$O(1)$的解法？？？ emmm看了一下好像并不行。。。然后发现我只会做两个操作的 首先我们来简化一下题意，题目要求$h=ax+by+cz(h&lt;=H)$这么一个$h$的所有不同取值的个数。 既然题目有三种操作，我们就一个个考虑过去。 我们首先考虑两种操作（这里我们选择操作2、3我就喜欢这么选） 假设我们这时通过几次操作2和几次操作3到了楼层$i$，再来看操作1对答案的贡献，这时候我们可以做任意次的操作1，此时操作1对答案的贡献就是$(H-i)/X$ 这样我们就可以统计答案了吗？ 并不行。在我们统计答案的时候，会发现有重复。而且$i \le 10^{18}$的范围我们也无法承担。 那么我们需要选择一种不存在重复的统计方式。 看下数据范围，发现$1 \le x,y,z \le 10^5$，所以肯定是在这里搞事情。 然后我们考虑进行$mod$操作。 记录$f_i$表示仅通过操作2和操作3可以到达的在$mod \space X=i$意义下的最小楼层。 那么我们可以得到$f$数组的转移式 $f_{(i+y)mod \space x}=f(i)+y$ $f_{(i+z)mod \space x}=f(i)+z$ 对转移式进行观察，我们发现这就是在求最短路时我们进行转移的式子！$f$在这里就相当于求最短路时的$dis$ 那么我们就可以快速求出所有$f_i$的值。 然后统计答案，就顺利解决了。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define Re register int#define LL long longstruct Edge&#123; int to,next,w;&#125;e[200005];int cnt,head[100005];std::queue&lt;int&gt; q;LL dis[100005],H,ans;int X,Y,Z,vis[100005];inline void AddEdge(int u,int v,int w) &#123;e[++cnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=cnt;&#125;inline void SPFA()&#123; memset(dis,0x3F,sizeof(dis)); q.push(1%X); dis[1%X]=1; vis[1%X]=1; //这里mod X处理X=1的情况 while (!q.empty()) &#123; int now=q.front(); q.pop(); vis[now]=0; for (Re i=head[now];i;i=e[i].next) if (dis[e[i].to]&gt;dis[now]+e[i].w) &#123; dis[e[i].to]=dis[now]+e[i].w; if (!vis[e[i].to]) vis[e[i].to]=1,q.push(e[i].to); &#125; &#125; return;&#125;int main()&#123; scanf("%lld%d%d%d",&amp;H,&amp;X,&amp;Y,&amp;Z); for (Re i=0; i&lt;X; ++i) AddEdge(i,(i+Y)%X,Y),AddEdge(i,(i+Z)%X,Z); SPFA(); for (Re i=0; i&lt;X; ++i) if (dis[i]&lt;=H) ans+=(H-dis[i])/X+1; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>SPFA</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO]奶牛集会MooFest]]></title>
    <url>%2Farticles%2FUSACO-%E5%A5%B6%E7%89%9B%E9%9B%86%E4%BC%9AMooFest%2F</url>
    <content type="text"><![CDATA[Description约翰家的N头奶牛每年都会参加“哞哞大会” 。哞哞大会是世界奶牛界的盛事。集会上 的活动很多，比如堆干草，跨栅栏，摸牛仔的屁股等等。当然，哞哞大叫肯定也包括在内。 奶牛们的叫声很大，很多奶牛在参加多年活动之后，实际上已经失去了一部分的听力。 奶牛们已经站在了一条直线上，i号奶牛的坐标为Xi，她只能听到大于Vi的声音。每头奶 牛的位置坐标都是唯一的。 如果i号和j号奶牛想对话，则他们使用的音量为max {Vi, Vj} × |Xi −Xj|。 N头奶牛可以组合成N(N − 1)/2对奶牛，假设每对奶牛都使用最小的音量在对话，请计 算所有奶牛产生的总音量是多少。 Input Format第一行：单个整数：$N,1 \le N \le 20000$ 第二行到第$N + 1$行：每行有两个用空格分开的整数，$Vi$和$Xi$，$1 \le Vi \le 20000， 1 \le Xi \le 20000$ Output Format第一行：单个整数，表示最小音量之和 Sample Input123454 3 1 2 5 2 6 4 3 Sample Output157 题解扯淡ing…… 有人说我博客都荒了（手动@mnihyc） 马上就NOIP2018了，我都没时间写一些东西啊。。。 然后现在写一篇题解算是给自己加个油emmm（我知道很水啦，但是我也没做什么好题…） 正题： 我们考虑式子$max(Vi,Vj) \times |Xi-Xj|$，很明显音量越高的对答案的贡献越大。 所以，我们可以考虑按照音量大小升序排序。那么我们怎么计算$|Xi-Xj|$呢？ 我们考虑用树状数组来维护一下在第$i$头牛前，$X$值比第$i$头牛小的个数。 那么这头牛$i$对于答案的贡献就为$(cnt \times Xi-len) \times Vi$ 其中$cnt$为在第$i$头牛前，$X$值比第$i$头牛小的个数；$len$为这些比$Xi$小的$X$值的和。 那么我们就要做树状数组同时维护两个值。 再来考虑另一半$X$比$i$大的怎么统计答案？ 我们记录从$1 \sim i$的$X$的和，减去$len$，就可以计算出新的$len$。而新的$cnt$就可以直接用$i-cnt$计算得。 那么另一半的贡献就是$(len-cnt \times Xi) \times Vi$ 这样我们就A了这题了。（学校的机子$O(N^2)$跑过去了什么鬼！） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define Re register int#define LL long longstruct Data&#123; int V,X;&#125;d[20005];int N,maxx,T[20005];LL S[20005],Sum,ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=x*10+ch-'0',ch=getchar(); var=w?-x:x;&#125;inline int lowbit(int x) &#123;return x&amp;-x;&#125;inline int max(int a,int b) &#123;return a&gt;b?a:b;&#125;inline bool cmp(Data a,Data b) &#123;return a.V&lt;b.V;&#125;inline void AddNum(int pos)&#123; for (Re i=pos; i&lt;=maxx; i+=lowbit(i)) ++T[i],S[i]+=pos; return;&#125;inline void Query(int pos,LL &amp;cnt,LL &amp;len)&#123; cnt=len=0; for (Re i=pos; i&gt;0; i-=lowbit(i)) cnt+=T[i],len+=S[i];&#125;int main(int argc, char const *argv[])&#123; read(N); LL cnt,len; for (Re i=1; i&lt;=N; ++i) read(d[i].V),read(d[i].X),maxx=max(maxx,d[i].X); std::sort(d+1,d+N+1,cmp); for (Re i=1; i&lt;=N; ++i) &#123; Sum+=d[i].X; AddNum(d[i].X); Query(d[i].X,cnt,len); ans+=(cnt*d[i].X-len)*d[i].V; cnt=i-cnt,len=Sum-len; ans+=(len-cnt*d[i].X)*d[i].V; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>USACO</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[声明]博客重组声明]]></title>
    <url>%2Farticles%2F%E5%A3%B0%E6%98%8E-%E5%8D%9A%E5%AE%A2%E9%87%8D%E7%BB%84%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[纪念：2018年10月24日00点28分54秒。。。我的博客再一次复苏了！！！ 其实没什么。。。 就是博主心血来潮想弄个Ubuntu在自己的笔记本上。 然后想都没想就开始装了。。。 嗯。。。我也知道Linux和Windows的分区方式不同。。。 主要我想都没想啊！！！ 后来，我还是滚回Win10了。。。 。 今天想写博客的时候才发现自己的文章都被格式化了。 ToT… 然后我就很愉快的重新搭建起了环境……………… 重新从网站上复制文章下来…………………… 重新瞎鸡er搞搞…………………… 经过一天的努力…………………… 终于搞好了。。。 然后写一发水博客。 嗯。 就这样。 水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发水一发]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[笔记]浅谈乘法逆元]]></title>
    <url>%2Farticles%2F%E7%AC%94%E8%AE%B0-%E6%B5%85%E8%B0%88%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[前言我们知道对于加、减、乘运算来说，取模运算都可以分配进去。而类似于$(a/b)\%mod​$这种式子，如果改成$(a\%mod/b\%mod)\%mod​$则有可能螺旋爆炸。所以我们就要用到逆元。 基本定义对于一个形似$ax \equiv 1(mod \space p)$的式子，我们称$x$是$a$在$mod \space p$意义下的逆元。记作$x=inv(a)$或$x=a−1$ 而对于$a$在$(mod \space p)$意义下存在逆元$x$的必要条件就是$gcd(a,p)=1$，即$a,p$互质。 用途继续我们在前言中提到的问题。对于$(a/b)\%mod$这种式子，我们不能直接取余。 所以我们就考虑化除为乘。什么意思呢？先假设$x$为$b$的逆元，即$x=b−1$。 有一个基本定理：除以一个数等于乘上这个数的逆元。 所以我们就可以把式子化成$(ax)\%mod$。这样我们就可以开心的直接取余啦O(∩_∩)O。 求法关于逆元的求法，这里给出$4$种方法，OI中常用。 1. 拓展欧几里得求解$ax \equiv 1(mod \space p)$这样的方程。 可以等价转化为求解$ax−kp=1$这样的方程。 那么我们就可以套用拓展欧几里得解方程。 但是要注意当且仅当$gcd(a,p)=1$时，才存在$a$在$(mod \space p)$意义下的逆元$x$。 然后我们求解完后把$x$调整到$1 \sim p−1$即可。 这个方法常用于单次求一个逆元。时间复杂度较优。常数较小。 时间复杂度为$O(logN)$ 1234567891011int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if (!b) &#123;x=1,y=0; return a;&#125; int ret=exgcd(b,a%b,y,x); y-=x*(a/b); return ret;&#125;int inv(int a,int p) //求解ax≡1(mod p)&#123; int x,y; return exgcd(a,p,x,y)==1?(x+p)%p:-1; //-1即为不存在逆元&#125; 2. 费马小定理先给出费马小定理：$a^{p−1} \equiv 1(mod \space p)$（$p$为质数） 怎么用呢？我们把上面的式子化作$ax \equiv 1(mod \space p)$的形式，就成为了$a \cdot a^{p−2} \equiv 1(mod \space p)$ 通过观察我们发现，此时的方程的解$x=a^{p−2}$，然后我们用快速幂求解一下就行了。 这个方法也常用于单次求一个逆元，但只限于$p$为素数的情况。 时间复杂度为$O(log N)$ 1234567891011121314int FastPower(int a,int x) //计算a^x&#123; int ret=1,base=a; //一般情况下要long long，根据题目意思来判断 while (x) &#123; if (x&amp;1) ret=ret*base%mod; base=base*base%mod; x&gt;&gt;=1; &#125; return ret%mod;&#125;int inv(int a,int p)&#123; return FastPower(a,p-2); //求逆元&#125; 3. 顺序递推法 有的时候题目需要多次用到$1 \sim N$里的逆元，我们就需要在更优的时间内求解出$1 \sim N$的逆元 接下来的2种方法都能实现在$O(N)$的时间复杂度内计算出$1 \sim N$的所有逆元 首先，这种方法还是只适用于$p$为质数的情况。 我们假设现在要求解$i$的逆元，$ix \equiv 1(mod \space p)$。 根据带余除法我们可以得到：$p=ik+r (k=⌊pi⌋)$ 那么我们就有：$ik+r \equiv 0(mod \space p)$ 注意$p$为质数，所以说$r$的逆元一定存在 由于我们要求$i$的逆元，即求$inv(i)$。所以我们将方程两边同乘$inv(i) \cdot inv(r)$ 由于$i \cdot inv(i) \equiv 1(mod \space p)$。那么，方程就变为 $=&gt;k \cdot inv(r)+inv(i) \equiv 0(mod \space p)$ $=&gt;inv(i) \equiv −k \cdot inv(r)(mod \space p)$ $=&gt;inv(i) \equiv −⌊\frac{p}{i}⌋ \cdot inv(p \space mod \space i)(mod \space p)$ $=&gt;inv(i) \equiv (p−⌊\frac{p}{i}⌋) \cdot inv(p \space mod \space i)(mod \space p)$ 这样的话就可以由前面推出当前的逆元了。 代码非常简短。 时间复杂度为$O(N)$ 123inv[1]=1; //注意初始化for (Re i=2; i&lt;=N; ++i) inv[i]=(P-P/i)*inv[P%i]%P; 4. 倒推求阶乘逆元首先，这种方法又还是只适用于$p$为质数的情况。 这种方法常用在组合数中。证法也比较简单。 我们将$k!$的逆元记作$facinv(k)$。 由于$facinv((k−1)!) \equiv k∗facinv(k!)(mod \space p)$ 所以$facinv(k!) \equiv (k+1)∗facinv((k+1)!)(mod \space p)$ 这样我们就可以求出$1!∼N!$的逆元。 但是必须先预处理出$N!$的逆元才能倒推回去。 预处理可以选择方法$1、2$中的任意一个 代码也是比较简短的。 时间复杂度为$O(N)$ 123facinv[N]=FastPower(a,p-2);for (Re i=N-1; i&gt;=1; --i) facinv[i]=(i+1)*facinv[i+1]%p; 这里还可以通过另外的方法再利用$facinv$数组再推算出$1 \sim N$的逆元。 这里就不做说明了，留给读者自己思考。（反正用第3种就好了嘿嘿嘿） 总结&amp;模板题逆元在OI竞赛中还是算比较常用的知识点了，所以今天特别写了一份比较详细的逆元整理笔记，希望对大家能有帮助O(∩_∩)O。 模板题Luogu P3811 在放上我的代码吧（凑字数(●ˇ∀ˇ●)） 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intlong long N,P,inv[3000005];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=x*10+ch-'0',ch=getchar(); var=w?-x:x;&#125;int main(int argc, char const *argv[])&#123; read(N),read(P); inv[1]=1; for (Re i=2; i&lt;=N; ++i) inv[i]=(P-P/i)*inv[P%i]%P; for (Re i=1; i&lt;=N; ++i) printf("%lld\n",inv[i]); return 0;&#125;]]></content>
      <tags>
        <tag>随手小记</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2010]生成字符串]]></title>
    <url>%2Farticles%2FSCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[Descriptionlxhgww最近接到了一个生成字符串的任务，任务需要他把n个1和m个0组成字符串，但是任务还要求在组成的字符串中，在任意的前k个字符中，1的个数不能少于0的个数。现在lxhgww想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？ Input Format输入数据是一行，包括2个数字n和m Output Format输出数据是一行，包括1个数字，表示满足要求的字符串数目，这个数可能会很大，只需输出这个数除以20100403的余数 Input Sample12 2 Output Sample12 Hint每点2秒 对于30%的数据，保证$1 \le m \le n \le 1000$ 对于100%的数据，保证$1 \le m \le n \le 1000000$ 题解灰常神奇的一道题（蒟蒻表示想不到。。。） 看了题解的构造之后感觉好像在哪里见过？？？ 然后往下翻，大佬说这是小学奥数（看来这是我小学的锅了。。。） 然后我还看见了$Catalan$数。（看来是我初中的锅了。。。） 其实这道题目在构造出模型后问题就迎刃而解。（$dalao$们就别吐槽了） 先来看一下答案$C^{M}_{N+M}−C^{M−1}_{N+M}$。为什么答案是这个呢？ 我们考虑建立一个坐标系，将$N+M$作为横坐标，$N−M$作为纵坐标。 横坐标表示的是字符串的长度，纵坐标表示的是$1$的个数和$0$的个数的差值。 然后对于在字符串后加入$1$，就相当于向右上方走一格。加入$0$则表示往右下方走一格。 那么题目的意思就是要求我们计算从$(0,0)$走到$(N+M,N−M)$，且不经过直线$y=−1$的所有方案数。 那么怎么统计方案呢？我们考虑先计算出所有情况再减去不合法情况。（正难则反？） 所有情况很显然是$C^{M}_{N+M}$，那不合法情况呢？ 不合法情况是一定会穿过直线的$y=−1$的路径。 只要第一次穿过了直线$y=−1$就可以算作不合法方案，那么通过对称，我们将$(0,0)$对称到$(0,−2)$，此时从$(0,−2)$走到$(N+M,N−M)$的所有方案数就是所谓的不合法方案数。为什么呢？ 由于$(N+M,N−M)$一定是在第一象限的，所以对于所有从$(0,−2)$走到$(N+M,N−M)$的路径，都一定会经过直线$y=−1$，就是说这里所有路径都是不合法的。 然后我们考虑路径中还未穿过直线$y=−1$的前面那一段。 我们可以通过对称将这段路径对称上去。这样就可以构造出一个从$(0,0)$开始走，经过直线$y=−1$后，再走到$(N+M,N−M)$的路径。 所以说，从$(0,−2)$走到$(N+M,N−M)$的所有方案数就是所谓的不合法方案数。 那么此时不合法方案总数就是$C^{M−1}_{N+M}$ 此时问题转化为求$C^{M}_{N+M}−C^{M−1}_{N+M}$ 但是题目要求求余，所以我们还需要结合逆元来计算。 这里就不多讲（下一篇会整理一下逆元） 放贷吗？放代码-&gt; 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register int#define LL long long#define MOD 20100403int N,M,d,fac[2000005];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=x*10+ch-'0',ch=getchar(); var=w?-x:x;&#125;void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) d=a,x=1,y=0; else exgcd(b,a%b,y,x),y-=x*(a/b);&#125;inline LL inv(LL a,LL n)&#123; LL x,y; exgcd(a,n,x,y); return d==1?(x+n)%n:-1;&#125;inline LL C(int x,int y)&#123; LL k=1LL*fac[x]*inv(fac[y],MOD)%MOD; return 1LL*k*inv(fac[x-y],MOD)%MOD;&#125;int main(int argc, char const *argv[])&#123; read(N),read(M); fac[0]=1; for (Re i=1; i&lt;=N+M; ++i) fac[i]=1LL*fac[i-1]*i%MOD; printf("%lld\n",(C(N+M,M)-C(N+M,M-1)+MOD)%MOD); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>各省省选</tag>
        <tag>组合数</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2016]D1T2天天爱跑步解题报告]]></title>
    <url>%2Farticles%2FNOIP2016-D1T2%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目妈耶~自己找去。。。 题解妈耶，终于把NOIP2016的题都啃下来了（我觉得这个最难。。） 这题主要的突破点就在于怎么把一条链的特殊情况想清楚。 如果一条链的会做，在树上也就不会有什么大问题了。 接下来我们直接讲树上的做法（各位大佬这么牛逼，还用管链上的吗？ε=ε=ε=┏(゜ロ゜;)┛逃 我们把一个人的路程分为两部分：起点到$LCA$，$LCA$到终点。 那么，在第一部分$(S \sim LCA)$中在$x$位置上的观察员看到玩家的前提是$w[x]=dep[S]−dep[x]$。 在第二部分$(LCA \sim T)$看到玩家的前提是$w[x]=len−(dep[T]−dep[x])$，其中$len$为起点到终点的长度。 把两个式子化为和$x$有关，就是$w[x]+dep[x]=dep[S],w[x]−dep[x]=len−deep[T]$。 我们只要把两个式子做成桶，然后对于每个点在遍历到时先记录一下对应桶内的初始值，因为此时桶里的值对他是不可能有贡献的，真正有贡献的是遍历完他的子树后与之前的值的差值。遍历完他的子树后我们先把把这个点作为起点的玩家信息塞进一个桶里，再把以这个点作为终点的玩家信息塞到另一个桶里，然后再统计答案。注意，如果一个点是一条路径上的$LCA$，那么，他如果会被观察到答案会被记录两次，所以我们要提前减去这个值。在这之后，我们再将以这个点作为$LCA$的所有路径在桶里清除掉就好了。 放代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register int#define MAX_N 300000using namespace std;struct Edge&#123; int to,next;&#125;e[2*MAX_N],G1[2*MAX_N],G2[2*MAX_N];int cnt,cnt1,cnt2,head[MAX_N],head1[MAX_N],head2[MAX_N],maxd;int N,M,W[MAX_N],S[MAX_N],T[MAX_N],dep[MAX_N],ans[MAX_N];int Sum[MAX_N],f[MAX_N][20],l[MAX_N],T1[2*MAX_N],T2[2*MAX_N];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=x*10+ch-'0',ch=getchar(); var=w?-x:x;&#125;inline void AddEdge(int u,int v)&#123; e[++cnt]=(Edge)&#123;v,head[u]&#125;; head[u]=cnt; e[++cnt]=(Edge)&#123;u,head[v]&#125;; head[v]=cnt;&#125;inline void AddEdge1(int u,int v) &#123;G1[++cnt1]=(Edge)&#123;v,head1[u]&#125;;head1[u]=cnt1;&#125;inline void AddEdge2(int u,int v) &#123;G2[++cnt2]=(Edge)&#123;v,head2[u]&#125;;head2[u]=cnt2;&#125;void preLCA(int now,int fa)&#123; dep[now]=dep[fa]+1; f[now][0]=fa; maxd=max(maxd,dep[now]); for (Re i=head[now];i;i=e[i].next) if (e[i].to!=fa) preLCA(e[i].to,now); return;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&gt;dep[v]) swap(u,v); for (Re i=19; i&gt;=0; --i) if (dep[u]&lt;=dep[f[v][i]]) v=f[v][i]; for (Re i=19; i&gt;=0; --i) if (f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; return u==v?u:f[u][0];&#125;void dfs(int now,int fa)&#123; int Last1=T1[W[now]+dep[now]],Last2=T2[W[now]-dep[now]+MAX_N]; for (Re i=head[now];i;i=e[i].next) if (e[i].to!=fa) dfs(e[i].to,now); T1[dep[now]]+=Sum[now]; for (Re i=head2[now];i;i=G2[i].next) ++T2[l[G2[i].to]-dep[T[G2[i].to]]+MAX_N]; ans[now]+=T1[W[now]+dep[now]]-Last1+T2[W[now]-dep[now]+MAX_N]-Last2; for (Re i=head1[now];i;i=G1[i].next) --T1[dep[S[G1[i].to]]],--T2[l[G1[i].to]-dep[T[G1[i].to]]+MAX_N];&#125;int main(int argc, char const *argv[])&#123; read(N),read(M); for (Re i=1,u,v; i&lt;N; ++i) read(u),read(v),AddEdge(u,v); for (Re i=1; i&lt;=N; ++i) read(W[i]); for (Re i=1; i&lt;=M; ++i) read(S[i]),read(T[i]),++Sum[S[i]]; preLCA(1,0); for (Re j=1; (1&lt;&lt;j)&lt;=maxd; ++j) for (Re i=1; i&lt;=N; ++i) f[i][j]=f[f[i][j-1]][j-1]; for (Re i=1; i&lt;=M; ++i) &#123; int k=LCA(S[i],T[i]); l[i]=dep[S[i]]+dep[T[i]]-2*dep[k]; if (W[k]==dep[S[i]]-dep[k]) --ans[k]; AddEdge1(k,i); AddEdge2(T[i],i); &#125; dfs(1,0); for (Re i=1; i&lt;=N; ++i) printf("%d ",ans[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>NOIP2016</tag>
        <tag>LCA</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2018]提高初赛划水记]]></title>
    <url>%2Farticles%2FNOIP2018-%E6%8F%90%E9%AB%98%E5%88%9D%E8%B5%9B%E5%88%92%E6%B0%B4%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[几天没写博客，博客都长草了… emmm…托了一整天才来更新（ε=ε=ε=┏(゜ロ゜;)┛） 大致说一下吧。。。 今年的初赛感觉难度大增，明显跟去年不在一个层次上好吗？？？ 考试的时候看见这鬼才超难的题目，我TM整个人都不好了。 考完了以后。。。跟同校大佬对了一下答案。 卧槽怎么我跟他们都不一样？？？？？？ 然后我就抱着沉重的心情回家了。。。 （一回家就有人给我发答案？？？） 然后我满怀不怀希望地打开了答案。 。 。 。 。 。 卧槽我阅读程序居然全对了。。。 嗯。。。果然是他们错了。嘿嘿。 然后估分大概在83左右吧。。。。。。 比起某江的大佬们，我还是太菜了。。。 ↑↑↑把这个看成10月13日写的吧 嗯。 今天出分数线了 胡建的初赛入围线是。。。。。。。。。。。。。。。。。。。。。44分。。。 我觉得oj*k. 至少我过了。 接下来就好好准备复赛吧。 （卧槽周天晚上考的英语好难啊QAQ）]]></content>
      <tags>
        <tag>NOIP2018</tag>
        <tag>随手小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[笔记]OI中的数学]]></title>
    <url>%2Farticles%2F%E7%AC%94%E8%AE%B0-OI%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[导言最近在学习OI中的数学，什么线性筛、欧拉函数等等。博主觉得这些知识点太繁杂了，决定整理一下，顺便做个笔记，也帮助大家整理一下知识点。顺便NOIP2018_RP++;ヾ(´∀`o)+。（真的只是浅谈） 1. 素数筛法关于素数筛法，有很多算法可以求解。至于算法的效率，高级算法的时间复杂度相对于暴力也有了质的飞跃。 1.1 暴力枚举筛（别逗了）要求解$1 \sim N$所有的质数，可以枚举$1 \sim N$所有数，然后对于每个数$K$我们可以枚举$2 \sim \sqrt{K}$，一一判断是否是$K$的因数。时间复杂度$O(N \sqrt{N})$ 1.2 Eratosthenes筛法摘一段百度百科的话。。 筛法是一种简单检定素数的算法。据说是古希腊的埃拉托斯特尼（Eratosthenes，约公元前274～194年）发明的，又称埃拉托斯特尼筛法（sieve of Eratosthenes）。 好了，具体怎么实现呢？ 由于一个合数总是可以分解成若干个质数的乘积，那么如果把质数（最初只知道2是质数）的倍数都去掉，那么剩下的就是质数了。 例如要查找$100$以内的质数，首先$2$是质数，把$2$的倍数去掉；此时$3$没有被去掉，可认为是质数，所以把$3$的倍数去掉；再到$5$，再到$7$，$7$之后呢，因为$8,9,10$刚才都被去掉了，而$100$以内的任意合数肯定都有一个因子小于$10(\sqrt{100})$，所以，去掉$2,3,5,7$的倍数后剩下的都是质数了。 在做EratosthenesEratosthenes的时候我们还可以考虑一个优化： 对于素数$p$，我们只筛除倍数$x \ge p$的数 为什么呢？如果$x&lt;p$，则$x$中一定有比$p$小的素因子，$p∗x$会在前面的筛选过程中被筛除。 123456789101112#define MaxN 1000000bool isPrime[MaxN+1];void Eratos(int n)&#123; isPrime[0]=isPrime[1]=false; for (int i=2; i&lt;=N; ++i) isPrime[i]=true; for (int i=2; i*i&lt;=N; ++i) if (isPrime[i]) for (int j=i*i; j&lt;=N; j+=i) isPrime[j]=false;&#125; 1.3 欧拉筛法（线性筛）素数筛法中最出名的应该算是线性筛了，它能够在$O(N)$的时间复杂度内筛出$1 \sim N$中所有的素数。 简单来说，线性筛就是筛除素数的倍数，但是要保证每个合数只被它的最小素因子筛除。 举个栗子↓↓↓ 素数表 筛除的数 素数表 筛除的数 2 {2} {4} 13 {2,3,5,7,11,13} {26,39} 3 {2,3} {6,9} 14 {2,3,5,7,11,13} {28} 4 {2,3} {8} 15 {2,3,5,7,11,13} {30,45} 5 {2,3,5} {10,15,25} 16 {2,3,5,7,11,13} {32} 6 {2,3,5} {12} 17 {2,3,5,7,11,13,17} {34} 7 {2,3,5,7} {14,21,35,49} 18 {2,3,5,7,11,13,17} {36} 8 {2,3,5,7} {16} 19 {2,3,5,7,11,13,17,19} {38} 9 {2,3,5,7} {18,27} 20 {2,3,5,7,11,13,17,19} {20} 10 {2,3,5,7} {20} 21 {2,3,5,7,11,13,17,19} {42} 11 {2,3,5,7,11} {22,33} 22 {2,3,5,7,11,13,17,19} {44} 12 {2,3,5,7,11} {24} … … … 枚举$2 \sim N$中的每一个数$i$：如果$i$是素数则保存到素数表中;利用$i$和素数表中的素数$prime[j]$去筛除$i \times prime[j]$，为了确保$i \times prime[j]$只被素数$prime[j]$筛除过这一次，要确保$prime[j]$是$i \times prime[j]$中最小的素因子，即$i$中不能有比$prime[j]$还要小的素因子。 123456789101112131415void Euler_sieve(int N)&#123; memset(isPrime,true,sizeof(isPrime)); prime[0]=0; //prime[0]用来记录当前素数个数 for(int i=2; i&lt;=N; ++i) &#123; if (isPrime[i]) prime[++prime[0]]=i; //把素数保存到素数表prime中，并更新素数个数 for (int j=1; j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;=N; ++j) &#123; isPrime[i*prime[j]]=false; //筛除i*prime[j] if (i%prime[j]==0) break; //当i中含有素因子prime[j]时中断循环,确保每个数只被它的最小素因子筛除 &#125; &#125;&#125; 2. 最大公因数和最小公倍数OI中求最大公因数的常用方法就是欧几里得算法（辗转相除法） 给个模版吧，时间复杂度为$O(log(a+b))$ 1int gcd(int a,int b) &#123;return b==0?a:gcd(b,a%b);&#125; 利用一些$gcd$的性质我们也可以很容易的证明出欧几里得算法。 这里就不做说明了。 关于最小公倍数，求法也很简单：$lcm(a,b)=a/gcd(a,b)∗b$ 这里最好先除再乘，防止爆$long \space long$ 3. 快速幂顾名思义，快速幂就是快速算底数的$N$次幂。其时间复杂度为$O(log_2N)$， 与朴素的$O(N)$相比效率有了极大的提高。 而快速幂的核心思想就是对指数进行二进制分解。举个栗子或许更好理解 例如：由于$11$的二进制是$1011$，所以$11=2^0+2^1+2^3$。所以可以进行转化$a^{11}=a^{2^0+2^1+2^3}$ 于是我们转化为求解$a^{11}=a^{2^0} \times a^{2^1} \times a^{2^3}$ 效率就可以大大的提升，快速幂可以用位运算来实现 b &amp; 1 //取b二进制的最低位，判断和1是否相同，相同返回1，否则返回0，可用于判断奇偶 b &gt;&gt; 1 //就是将b的二进制右移一位，去掉b的二进制最低位(即第0位)，相当于除2 12345678910int FastPower(int a,int b)&#123; int ret=1,base=a; while (b) &#123; if(b&amp;1) ret*=base; base*=base; b&gt;&gt;=1; &#125; return ret;&#125; 4. 欧拉函数4.1 欧拉函数定义在数论，对正整数N，欧拉函数是小于或等于N的正整数中与N互质的数的数目$(\varphi(1)=1)$。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、$\varphi$函数、欧拉商数等。 例如$\varphi(8)=4$，因为$1,3,5,7$均和$8$互质。 4.2 求解欧拉函数求欧拉函数有一个通式：$\varphi(x)=x∗\prod^{N}_{i=1}(1−\frac{1}{pi})$ 其中$p1,p2……pn$为$x$的所有质因数，$x$是不为0的整数。 怎么证明呢，其实有一种很好理解的证明方法。 用数学期望来证明的话，对于$x$的每个素因子$pi$，在$1 \sim N$的范围内，含质因子$pi$的概率为$\frac{1}{pi}$，所以不含质因子$pi$的概率为$1−\frac{1}{pi}$，然后把概率乘起来就是$\varphi(x)$的值了。 4.3 欧拉函数的性质有一个很明显的定理，当$p$为质数时，$\varphi(p)=p−1$ 欧拉定理：对于互质的正整数$a$和$n$，有$a^{\varphi(n)}≡1(mod \space n)$。 欧拉函数是积性函数——若$m,n$互质，$\varphi(mn)=\varphi(m)\varphi(n)$。 若$n$是质数$p$的$k$次幂，$\varphi(n)=p^k−p^{k−1}=(p−1)p^{k−1}$，因为除了$p$的倍数外，其他数都跟$n$互质。 特殊性质：当$n$为奇数时，$\varphi(2n)=\varphi(n)$ 欧拉函数还有这样的性质： 设$a$为$N$的质因数 若$N\%a=0 \space and \space (N/a)\%a=0$则有$\varphi(N)=\varphi(N/a) \times a$ 若$N\%a=0 \space and \space (N/a)\%a!=0$则有$\varphi(N)=\varphi(N/a) \times (a−1)$ 4.4 线性求欧拉函数关于欧拉函数的线性筛法，利用上面的两条性质可以实现，下面给出了代码 1234567891011121314151617void Euler_sieve(int N)&#123; memset(isPrime,true,sizeof(isPrime)); phi[1]=1; prime[0]=0; //记录当前素数个数，phi[i]为i对应的欧拉函数值 for (int i=2; i&lt;=N; ++i) &#123; if (isPrime[i]) prime[++prime[0]]=i,phi[i]=i-1; //把素数保存到素数表prime中，并更新素数个数 for (int j=1; j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;=N; ++j) &#123; isPrime[i*prime[j]]=false; //筛除i*prime[j] if (i%prime[j]==0) &#123;phi[i*prime[j]]=phi[i]*prime[j];break;&#125; //当i中含有素因子prime[j]时中断循环,确保每个数只被它的最小素因子筛除 else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>欧拉函数</tag>
        <tag>笔记</tag>
        <tag>线性筛</tag>
        <tag>GCD</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国庆集训]Day6解题报告]]></title>
    <url>%2Farticles%2F%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD-Day6%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接戳我n(≧▽≦)n 注：T3换为跳跳棋 T1我真是蒟蒻。。。 先放一段官方题解 在题目没有给出特殊约束的情况下永远不要考虑对背包算法的优化 因为这是不可能的事情 …… 然后。。。我真的在想怎么优化这个01背包…QAQ 然后。。。就没然后了。。。果断交了一个$O(N^3)$的暴力。。。 那么，我们现在来讲正解。我们考虑做两次的01背包，先正着做一次，再倒着做一次。 （常用手法。一般取掉一个元素的话，就是让原来的序列变成两段。然后正着做一遍，倒着做一遍。） 记录$f[i][j]$为从第$1 \sim i$个物品，花费钱数为$j$时，所能取到的最大喜好程度。 记录$g[i][j]$为从第$i \sim N$个物品，花费钱数为$j$时，所能取到的最大喜好程度。 那么我们就可以在$O(2 \times N^2)$的时间内预处理出这两个数组。 然后对于每次询问，我们可以枚举买前面物品用的钱，然后统计答案，取最大值即可。 总的来说还是我太菜了。 $Mark$一下： 在题目没有给出特殊约束的情况下永远不要考虑对背包算法的优化 在题目没有给出特殊约束的情况下永远不要考虑对背包算法的优化 在题目没有给出特殊约束的情况下永远不要考虑对背包算法的优化 重要的$Mark$要记$3$遍！ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intint N,M,A[1005],B[1005],f[1005][1005],g[1005][1005],a,b;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline int max(int a,int b) &#123;return a&gt;b?a:b;&#125;int main(int argc, char const *argv[])&#123; read(N); for (Re i=1,tmp; i&lt;=N; ++i) read(A[i]),read(B[i]),read(tmp); for (Re i=1; i&lt;=N; ++i) for (Re j=0; j&lt;=1000; ++j) &#123; f[i][j]=f[i-1][j]; if (j&gt;=A[i]) f[i][j]=max(f[i][j],f[i-1][j-A[i]]+B[i]); &#125; for (Re i=N; i&gt;=1; --i) for (Re j=0; j&lt;=1000; ++j) &#123; g[i][j]=g[i+1][j]; if (j&gt;=A[i]) g[i][j]=max(g[i][j],g[i+1][j-A[i]]+B[i]); &#125; read(M); while (M--) &#123; read(a),read(b); int ans=0; for (Re i=0; i&lt;=b; ++i) ans=max(ans,f[a][i]+g[a+2][b-i]); printf("%d\n",ans); &#125; return 0;&#125; T2虽然我会$Trie$树，但是，$O(N^2)$40分我觉得不错！（我想不到，我是蒟蒻） 初三翘掉晚自习到高中部上课听的$Trie$树，但是从来没用过。。。 讲正经的了。。。 首先来明确一下$lowbit(x)$的意义，它求的是$x$在二进制表示下，从低位到高位出现的第一个$1$的位置所对应的数。 再来考虑任意一对数$Ai,Aj$，我们要求$lowbit(Ai \space xor \space Aj)$，即$Ai,Aj$在二进制表示下从低到高第一次出现对应位置的数不同时，这一位所对应的数。 于是，我们考虑做一棵$Trie$树，由于$lowbit(x)$求的是最低位的$1$，所以我们考虑倒序将数字插入到$Trie$树中，每一位对应一个结点，这样这棵$Trie$树就是一棵二叉树。 那么怎么统计答案呢？ 我们还是考虑任意一对数$Ai,Aj$，当$Ai,Aj$的二进制位第一次不同时，它对答案才会有贡献。 我们假设我们正在遍历一个数$x$，那么当$x$遍历到自己的某一位时（即某个结点），如果发现该节点有两个儿子，就代表说一定有其他的数从第一位一直到这一位的二进制表达式都与它相同，但在下一位，它们不同了。 那么这有什么意义呢？此时他们对应位的数字第一次不同，我们之前说明过，在此时，它对答案有贡献。 那么问题来了，怎么知道有多少个数在此时与我们正在遍历的数$x$不同呢？我们可以对每个结点维护经过这一个结点的数的个数，然后我们就可以直接统计答案了。 注意$long \space long$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register inttypedef unsigned long long LL;int N,tot;const LL MOD=199907210507;LL A[100005],e2[61],cnt[6000005],tr[6000005][2],ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline int max(int a,int b) &#123;return a&gt;b?a:b;&#125;LL Solve(LL x)&#123; LL ret=0; for (Re cur=0,i=0; i&lt;60; ++i) &#123; int c=(x&amp;1); if (tr[cur][c^1]) (ret+=cnt[tr[cur][c^1]]%MOD*e2[i]%MOD)%=MOD; cur=tr[cur][c]; x&gt;&gt;=1; &#125; return ret;&#125;int main(int argc, char const *argv[])&#123; read(N); e2[0]=1; for (Re i=1; i&lt;=60; ++i) e2[i]=e2[i-1]&lt;&lt;1; for (Re i=1; i&lt;=N; ++i) &#123; read(A[i]); LL tmp=A[i]; for (Re cur=0,d=0; d&lt;60; ++d) &#123; int c=(tmp&amp;1); ++cnt[cur]; if (!tr[cur][c]) tr[cur][c]=++tot; cur=tr[cur][c]; tmp&gt;&gt;=1; &#125; &#125; for (Re i=1; i&lt;=N; ++i) (ans+=Solve(A[i]))%=MOD; printf("%llu\n",ans); return 0;&#125; T3emmm…虽然是Day6的题，但是我10月8号中午才打出来（卧槽作业真TM多，我TM写了一整天） 。。。 考试的时候看见这题，感觉好像在哪里见过。然后我考完后到Luogu上搜了一下。。。 [国家集训队]跳跳棋清华集训 顿时惊了，算了算了写作业。。。 好了不扯了。 我们考虑一组坐标(x,y,z)(x,y,z)，那么每一次的决策可以分成下面几种情况： 让中间的棋子往左跳，最后的坐标就是(2x−y,x,z) 让中间的棋子往左跳，最后的坐标就是(x,z,2z−y) 让旁边的棋子往中间跳，这里还要分两种情况，我就不细写了。 然后呢，我们来观察一下这种变换，我们考虑往中间跳的操作，(u,v,w)的u或v往中间跳，得到状态(x,y,z)，把这个操作反过来，就相当于(x,y,z)往外跳到了状态(u,v,w) 所以我们可以考虑建一棵树，操作1,2就相当于当前状态的两个儿子，而操作33就是跳到它的父亲。 但是我们又面临了一个问题，状态太多存不下。 因为棋子都是一样的，所以我们只需要存下他的相对位置。 那么不妨令t1=y−x,t2=z−y，不妨设t1&gt;t2，那么显然(x,y,z)的父亲(u,v,w)，满足v−u=t1−t2,w−v=t2，定义状态(t1,t2)可以转移到状态(t1−t2,t2)。那么显然每一个状态(x,y,z)对应唯一一个(t1,t2)，我们发现了什么？如果t1&gt;t2，那么(t1,t2)−&gt;(t1−t2,t2)或(t1,t2−t1)，那么难道不可以用取模来加速运算吗？即(t1,t2)−&gt;(t1%t2,t2)或(t1,t2%t1)，刚好和求gcd一样！因此这么做就变成O(log2t2)了！ 于是我们可以用O(log2k)的时间得到状态(x,y,z)往中间跳k步得到的状态；那么，我们首先判断初始状态和目标状态是否在一颗树中（即根节点是否相同），如果不同输出”NO”；否则，回忆倍增求lca的过程，类似的我们可以把初始状态和目标状态先提到同一个深度，然后二分它们到其lca的距离即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define INF int(1e9)#define Re register intusing namespace std;struct Node&#123; int p[4]; void read() &#123;scanf("%d%d%d\n",&amp;p[1],&amp;p[2],&amp;p[3]);&#125; bool operator != (const Node a) const &#123; for (Re i=1; i&lt;=3; ++i) if (this-&gt;p[i]!=a.p[i]) return 1; return 0; &#125;&#125;S,T;int deep;Node GetStatus(Node s,int l)&#123; int k=0; for (deep=0; l; deep+=k) &#123; int t1=s.p[2]-s.p[1],t2=s.p[3]-s.p[2]; if (t1==t2) return s; if (t1&lt;t2) &#123; k=min((t2-1)/t1,l); l-=k; s.p[1]+=k*t1; s.p[2]+=k*t1; &#125; else &#123; k=min((t1-1)/t2,l); l-=k; s.p[2]-=k*t2; s.p[3]-=k*t2; &#125; &#125; return s;&#125;int main(int argc, char const *argv[])&#123; S.read(),T.read(); sort(S.p+1,S.p+4); sort(T.p+1,T.p+4); Node fa1=GetStatus(S,INF); int d1=deep; Node fa2=GetStatus(T,INF); int d2=deep; if (fa1!=fa2) &#123;puts("NO"); return 0;&#125; if (d1&gt;d2) swap(d1,d2),swap(S,T); T=GetStatus(T,d2-d1); int l=0,r=d1; while (l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if (GetStatus(S,mid)!=GetStatus(T,mid)) l=mid+1; else r=mid-1; &#125; printf("YES\n%d\n",d2-d1+2*l); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>LCA</tag>
        <tag>2018国庆集训</tag>
        <tag>二分答案</tag>
        <tag>背包DP</tag>
        <tag>Tire树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国庆集训]Day5解题报告]]></title>
    <url>%2Farticles%2F%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD-Day5%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接戳我n(≧▽≦)n T1这题其实不难。。。（日常开头） 我考试时就想出正解了（嗯考试结束前半小时想出来的），然后卧槽扫雷高级过了！！！再来一把！！！ emmm。。。 我们考虑一个对一个联通块进行操作，它实际就就是联通块的扩张，一个联通块变得更Big了 然后呢，我们可以考虑缩点，一个联通块缩成一个点 然后不同的相邻联通块连一条权值为1的边 代表可以花费1的代价使得两个联通块颜色一样 枚举第一个操作的点，则在新图中以它为起点的最长路径就是当前答案 然后对每个点进行操作，对每次的答案取最小值就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#define ID(x,y) ((x-1)*M+(y))#define Re register intusing namespace std;struct Edge&#123; int to,next;&#125;e[100000];const int dx[3]=&#123;0,1&#125;,dy[3]=&#123;1,0&#125;;queue&lt;int&gt; q;char str[75];int cnt,head[10000],u[10000],v[10000],tot;int N,M,map[75][75],fa[10000],c[10000],vis[10000],dis[10000],ans=0x7FFFFFFF;inline bool Check(int x,int y) &#123;return 1&lt;=x&amp;&amp;x&lt;=N&amp;&amp;1&lt;=y&amp;&amp;y&lt;=M;&#125;int GetF(int x) &#123;return x==fa[x]?x:fa[x]=GetF(fa[x]);&#125;inline void Union(int x,int y) &#123;fa[GetF(x)]=GetF(y);&#125;inline void AddEdge(int u,int v)&#123; e[++cnt]=(Edge)&#123;v,head[u]&#125;; head[u]=cnt; e[++cnt]=(Edge)&#123;u,head[v]&#125;; head[v]=cnt;&#125;inline void Preprocess()&#123; for (Re i=N*M; i; --i) fa[i]=i; for (Re i=1; i&lt;=N; ++i) for (Re j=1; j&lt;=M; ++j) for (Re p=0; p&lt;2; ++p) &#123; int nx=i+dx[p],ny=j+dy[p]; if (Check(nx,ny)) if (map[i][j]==map[nx][ny]) Union(ID(i,j),ID(nx,ny)); else u[++tot]=ID(i,j),v[tot]=ID(nx,ny); &#125;&#125;inline void BFS(int S)&#123; memset(dis,0x3F,sizeof(dis)); int len=0; dis[S]=0; q.push(S); while (!q.empty()) &#123; int now=q.front(); q.pop(); vis[now]=1; for (Re i=head[now];i;i=e[i].next) if (dis[e[i].to]==0x3F3F3F3F) &#123; dis[e[i].to]=dis[now]+1; q.push(e[i].to); len=max(len,dis[e[i].to]); &#125; &#125; if ((c[S])^(len%2)) ++len; ans=min(ans,len); return;&#125;int main(int argc, char const *argv[])&#123; scanf("%d%d",&amp;N,&amp;M); for (Re i=1; i&lt;=N; ++i) &#123; scanf("%s",str+1); for (Re j=1; j&lt;=M; ++j) map[i][j]=(str[j]=='B'),c[ID(i,j)]=map[i][j]; &#125; Preprocess(); for (Re i=1; i&lt;=tot; ++i) AddEdge(GetF(u[i]),GetF(v[i])); for (Re i=N*M; i; --i) if (fa[i]==i) BFS(i); printf("%d\n",ans); return 0;&#125; T2一个神奇的做法（我们机房一个大佬的神奇想法）自己看程序吧（意会） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intint N,K,Q,map[3005][3005],S[3005][3005],l[3005][3005],r[3005][3005],ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline int abs(int x) &#123;return x&lt;0?-x:x;&#125;inline int max(int a,int b) &#123;return a&gt;b?a:b;&#125;int main(int argc, char const *argv[])&#123; read(N),read(K),read(Q); for (Re i=1,x,y; i&lt;=K; ++i) read(x),read(y),++map[x+N][y+N]; for (Re i=1; i&lt;=3*N; ++i) for (Re j=1; j&lt;=3*N; ++j) &#123; S[i][j]=S[i-1][j]+l[i-1][j-1]+r[i-1][j+1]+map[i][j]; l[i][j]=l[i-1][j-1]+map[i][j]; r[i][j]=r[i-1][j+1]+map[i][j]; &#125; while (Q--) &#123; int s,ans=0; read(s); for (Re i=1+N; i&lt;=N+N; ++i) for (Re j=1+N; j&lt;=N+N; ++j) ans=max(ans,S[i+s][j]-S[i-1][j-s]-S[i-1][j+s]- l[i-1][j-s-1]-r[i-1][j+s+1]+S[i-s-1][j]); printf("%d\n",ans); &#125; return 0;&#125; 如果这个不懂的，看看官方题解吧。。。 对于每个询问，暴力枚举老蛤的位置， 统计答案那么对原图斜着维护前缀和就行了或者将曼哈顿距离转化成切比雪夫距离统计正方形区域前缀和注意方案二中枚举的老蛤的位置要在原图内 今天实在太困了。。。不写了 T3我们设$f[S][T]$表示点的集合为$S$，叶子节点的集合为$T$时的数量。 然后转移方程显然。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intint N,M,K,e2[11],u[50],v[50],f[1024][1024],cnt[1024],ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline int lowbit(int x) &#123;return x&amp;-x;&#125;int main(int argc, char const *argv[])&#123; read(N),read(M),read(K); e2[0]=1; for (Re i=1; i&lt;=10; ++i) e2[i]=e2[i-1]&lt;&lt;1; for (Re i=1; i&lt;=M; ++i) &#123; read(u[i]),--u[i],read(v[i]),--v[i]; f[e2[u[i]]|e2[v[i]]][e2[u[i]]|e2[v[i]]]+=2; &#125; for (Re i=1; i&lt;e2[N]; ++i) &#123; int tot=0; for (Re x=i; x; x-=lowbit(x)) ++tot; cnt[i]=tot; &#125; for (Re i=1; i&lt;e2[N]; ++i) for (Re j=1; j&lt;e2[N]; ++j) if (f[i][j]) &#123; f[i][j]/=cnt[j]; for (Re p=1; p&lt;=M; ++p) &#123; int _u=u[p],_v=v[p]; if ((i&amp;e2[_u])&amp;&amp;(i&amp;e2[_v])) continue; if (!(i&amp;e2[_u])&amp;&amp;!(i&amp;e2[_v])) continue; int New=i|e2[_u]|e2[_v],Leaf=j; if (!(i&amp;e2[_u])) Leaf|=e2[_u]; else if (j&amp;e2[_u]) Leaf-=e2[_u]; if (!(i&amp;e2[_v])) Leaf|=e2[_v]; else if (j&amp;e2[_v]) Leaf-=e2[_v]; f[New][Leaf]+=f[i][j]; &#125; &#125; for (Re i=1; i&lt;e2[N]; ++i) if (cnt[i]==K) ans+=f[e2[N]-1][i]; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>思维题</tag>
        <tag>2018国庆集训</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国庆集训]Day4解题报告]]></title>
    <url>%2Farticles%2F%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD-Day4%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接戳我n(≧▽≦)n T1今天我又在划水了，嗯，题解也水一下吧。 这题考场上我想出正解了。。。可是打挂了（就当我A了） 这题其实并不难，我们只需要维护一个前缀和，再维护从前往后的前缀和最小值，和从后往前的前缀和最小值即可。 具体看代码吧。（今天不在状态，不想写） 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intint N,A[1000005],Sum[1000005],ps[1000005],qs[1000005],ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline int min(int a,int b) &#123;return a&lt;b?a:b;&#125;int main(int argc, char const *argv[])&#123; read(N); ps[0]=qs[N+1]=0x3FFFFFFF; for (Re i=1; i&lt;=N; ++i) &#123; read(A[i]); Sum[i]=Sum[i-1]+A[i]; ps[i]=min(ps[i-1],Sum[i]); &#125; for (Re i=N; i&gt;=1; --i) qs[i]=min(Sum[i],qs[i+1]); for (Re i=1; i&lt;=N; ++i) if (ps[i-1]+Sum[N]-Sum[i-1]&gt;=0&amp;&amp;qs[i]-Sum[i-1]&gt;=0) ++ans; printf("%d\n",ans); return 0;&#125; T2这题实际上并不难，我们先考虑不加入这条神奇的边。然后跑最短路。 然后分情况讨论 从1到N的最短路有这几种情况： 直接从1到N，不经过$u,v$ 路径为：$1−&gt;u−&gt;v−&gt;N$ 路径为：$1−&gt;v−&gt;u−&gt;N$ 然后每次考虑选择这三种情况中最小的即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#define Re register int#define pa pair&lt;long long,int&gt;#define mp make_pairusing namespace std;struct Edge&#123; int to,next,w;&#125;e[1000005];priority_queue &lt;pa,vector&lt; pa &gt;,greater&lt;pa&gt; &gt; q;int N,M,K,cnt,head[200005],vis[200005];long long dis[200005],len1,len2,ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline void AddEdge(int u,int v,int w)&#123; e[++cnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=cnt; e[++cnt]=(Edge)&#123;u,head[v],w&#125;; head[v]=cnt;&#125;inline void Dijkstra(int S)&#123; for (Re i=1; i&lt;=N; ++i) dis[i]=4e18; dis[S]=0; q.push(mp(0,S)); memset(vis,0,sizeof(vis)); while (!q.empty()) &#123; int now=q.top().second; q.pop(); if (vis[now]) continue; vis[now]=1; for (Re i=head[now];i;i=e[i].next) if (dis[e[i].to]&gt;dis[now]+e[i].w) &#123; dis[e[i].to]=dis[now]+e[i].w; q.push(mp(dis[e[i].to],e[i].to)); &#125; &#125; return;&#125;int main(int argc, char const *argv[])&#123; read(N),read(M),read(K); int u,v,w; for (Re i=1; i&lt;=M-1; ++i) read(u),read(v),read(w),AddEdge(u,v,w); Dijkstra(1); read(u),read(v); len1=dis[N]; AddEdge(u,v,0); Dijkstra(u); len2=dis[1]+dis[N]; for (Re i=1,k; i&lt;=K; ++i) &#123; read(k); ans=int(4e18); ans=min(len1,len2+k); ans&gt;=1e18?printf("+Inf\n"):printf("%lld\n",ans); &#125; return 0;&#125; T3这算是Day4的比较简单的题目了（个人观点）。但是OJOJ上还是把这题难度硬生生标成Mid 然后其他两题难度都是Low，莫非是我太菜了？？？（黑人问号.jpg） 我们来观察一下这个神奇的函数$\sum_{d|n}\varphi(d)=n$ 可能一开始你无法发现出什么规律，但是做题嘛，手算肯定要先算出来啊。 于是我们开始手算 当$n=1$时，$n=f(1)=1$，所以我们得到$f(1)=1$ 当$n=2$时，$n=f(1)+f(2)=2$，所以$f(2)=1$ 当$n=3$时，$n=f(1)+f(3)=3$，所以$f(3)=2$ 当$n=4$时，$n=f(1)+f(2)+f(4)=4$，所以$f(4)=2$ … 然后你们慢慢算吧。。。最后发现，实际上这就是欧拉函数的值。 而关于公式$\sum_{d|n}\varphi(d)=n$实际上是欧拉函数的一个性质（想要证明的同学请自行百度反正我是找规律） 然后我们只需要一个线性筛欧拉函数模板就可以过了。（话说我昨晚才刚整理了笔记啊喂） 但是 你会发现有几个数据是真的狗 第$3,8,9$个数据点就要你特判才能过去的。 这里我就不做解释了，引用一下官方题解的解释 线性筛可以得到70分特判全是7的点可得10分$n=5$的提答点可以通过$\sqrt N$的暴力预处理好剩下一个点，三个数都是质数然而我的代码跑了一个下午没有分解完 （你自己代码跑了一下午都没分解完，那我真是太阳了） 下面放代码↓ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#define LL long long#define Re register int#define MAX_X 10000000bool isPrime[10000005];int N,A[10000005],Prime[10000005],phi[10000005];long long ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;void Euler_sieve()&#123; memset(isPrime,1,sizeof(isPrime)); isPrime[1]=0; phi[1]=1; for (Re i=2; i&lt;=MAX_X; ++i) &#123; if (isPrime[i]) Prime[++Prime[0]]=i,phi[i]=i-1; for (Re j=1; j&lt;=Prime[0]&amp;&amp;i*Prime[j]&lt;=MAX_X; ++j) &#123; isPrime[i*Prime[j]]=0; if (i%Prime[j]==0) &#123;phi[i*Prime[j]]=phi[i]*Prime[j]; break;&#125; else phi[i*Prime[j]]=phi[i]*(Prime[j]-1); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; read(N); if (N==30000000) &#123;printf("%lld\n",1LL*N*6); return 0;&#125; else if (N==5) &#123;printf("21517525747423580\n"); return 0;&#125; else if (N==3) &#123;printf("525162079891401242\n"); return 0;&#125; Euler_sieve(); for (Re i=1,A; i&lt;=N; ++i) read(A),ans+=phi[A]; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>2018国庆集训</tag>
        <tag>前缀和</tag>
        <tag>Dijkstra</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国庆集训]Day3解题报告]]></title>
    <url>%2Farticles%2F%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD-Day3%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接戳我n(≧▽≦)n T1这题实际上并不难（我就是没打出来），只不过需要能够发现其中的奥妙就可以了。 我拿到这题时首先想的是状压DP，然后自己瞎打一通 1234for (Re S=1; S&lt;(1&lt;&lt;K); ++S) for (Re i=1; i&lt;=N; ++i) for (Re t=head[i];t;t=e[t].next) f[e[t].to][S|pd[e[t].to]]=min(f[e[t].to][S|pd[e[t].to]],f[i][S]+e[t].w); 嗯。。。打了这么一个东西，后来发现这是错的。。。 并不能说我没想过正解的做法，只不过是被我迅速否定了。 接下来讲讲正解： 实际上我们很容易注意到$K \le 5$这个条件，肯定就是在这上面做文章（傻*才想状压）。 所以我们可以考虑先做$K$遍的SPFA预处理出K个超市到各个地方的距离。 预处理后又有什么用呢？ 我们考虑任意一个起点$u$（$u$不是超市），对于$u$来说，肯定是走到这$K$个超市中的某一个，然后走到其他几个超市（可能经过自己），最后再从某个超市回来。 所以呢，我们可以考虑再预处理一个数组$f[i][j]$，表示走完这$K$超市，起点为第$i$个超市，终点为第$j$个超市的最短路径（可能经过我们的$u$）。 这样我们可以通过$dfs$预处理出$f$数组。 那么统计答案的时候我们只需要枚举个这$K$个超市中的起点和终点就可以了。 统计答案：ans=min(ans,dis[p][i]+dis[q][i]+f[p][q]) 到此，这题就被我们暴力过掉了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;queue&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#define Re register intstruct Edge&#123; int to,next,w;&#125;e[100005];std::queue&lt;int&gt; q;int cnt,head[10005],St,ans=0x7FFFFFFF;int N,M,K,k[6],dis[6][10005],vis[10005],f[6][6];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline void AddEdge(int u,int v,int w)&#123; e[++cnt]=(Edge)&#123;v,head[u],w&#125;; head[u]=cnt; e[++cnt]=(Edge)&#123;u,head[v],w&#125;; head[v]=cnt;&#125;inline void SPFA(int S,int *dist)&#123; for (Re i=1; i&lt;=N; ++i) dist[i]=0x3FFFFFFF,vis[i]=0; q.push(S); dist[S]=0; vis[S]=1; while (!q.empty()) &#123; int now=q.front(); q.pop(); vis[now]=0; for (Re i=head[now];i;i=e[i].next) if (dist[e[i].to]&gt;dist[now]+e[i].w) &#123; dist[e[i].to]=dist[now]+e[i].w; if (!vis[e[i].to]) vis[e[i].to]=1,q.push(e[i].to); &#125; &#125; return;&#125;inline void dfs(int d,int now,int len)&#123; if (d==K) &#123;f[St][now]=std::min(f[St][now],len); return;&#125; vis[now]=1; for (Re i=1; i&lt;=K; ++i) if (!vis[i]) dfs(d+1,i,len+dis[now][k[i]]); vis[now]=0; return;&#125;int main(int argc, char const *argv[])&#123; read(N),read(M),read(K); for (Re i=1; i&lt;=K; ++i) read(k[i]); for (Re i=1,u,v,w; i&lt;=M; ++i) read(u),read(v),read(w),AddEdge(u,v,w); for (Re i=1; i&lt;=K; ++i) SPFA(k[i],dis[i]); memset(f,63,sizeof(f)); memset(vis,0,sizeof(vis)); for (Re i=1; i&lt;=K; ++i) St=i,dfs(1,i,0); for (Re i=1; i&lt;=K; ++i) vis[k[i]]=1; for (Re i=1; i&lt;=N; ++i) &#123; if (vis[i]) continue; for (Re p=1; p&lt;=K; ++p) for (Re q=1; q&lt;=K; ++q) if (p!=q) ans=std::min(ans,dis[p][i]+dis[q][i]+f[p][q]); &#125; printf("%d\n",ans); return 0;&#125; T2这道题官方题解的做法是倍增，实际上有更好的做法。 先看一下官方题解吧 对于20%的数据可以每次询问扫一次所有边，用并查集判断是否还是一棵树。对于另外20%的数据，需要观察出一个性质：如果新加入的那条边的两个端点在原树上面的路径包含删去的边，那么增删边之后还是一棵树，否则就不是。由于这部分数据树为随机生成，所以期望树高是logn级别的，因此可以直接每次往上跳判断经过的边。（也许还能有别的水法？）对于100%的数据，我们继续沿用刚才的算法，由于树高可能相当大，我们可以先遍历一次原树，确定每个点在原树的深度，然后每次询问用倍增算法找到询问加入的边的两个端点往上跳到的删去的边所在深度，再判断一下是不是删去的那条边就可以了。 感觉就非常麻烦。而所谓更简便的做法就是利用树的$dfs$序做文章。 我们考虑断边的操作，它的实质就是把我们一棵完整的树拆成了一棵小子树（不含根节点）和一大团的东西（含根节点）。 再考虑一下连边的操作，如果我们能够证明出连边的两点分别在这两坨东西里面，我们就会发现CD没有得逞。 那么怎么证明呢。 在考场的时候，我用的是并查集（果然蒟蒻就是只会暴力） 实际上用树的$dfs$序可以很好地进行判断。（至于树的遍历、$dfs$序是什么不在本题解范围内，请自行了解） 我们记录每个结点变灰的时间$G[i]$，每个节点变黑的时间$B[i]$，然后判断连边的两点是否是一点在小子树中，一点不在小子树中。时间复杂度为$O(N+Q)$的。（跑的飞快啊） 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intstruct Edge&#123; int to,next;&#125;e[400005];int cnt,head[200005],dep[200005];int N,Q,u[200005],v[200005],G[200005],B[200005],TimeStamp;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline void AddEdge(int u,int v)&#123; e[++cnt]=(Edge)&#123;v,head[u]&#125;; head[u]=cnt; e[++cnt]=(Edge)&#123;u,head[v]&#125;; head[v]=cnt;&#125;void dfs(int now,int fa)&#123; G[now]=++TimeStamp; dep[now]=dep[fa]+1; for (Re i=head[now];i;i=e[i].next) if (e[i].to!=fa) dfs(e[i].to,now); B[now]=++TimeStamp;&#125;int main(int argc, char const *argv[])&#123; read(N); for (Re i=1; i&lt;N; ++i) read(u[i]),read(v[i]),AddEdge(u[i],v[i]); dfs(1,0); read(Q); int x,y,z; while (Q--) &#123; read(x),read(y),read(z); int p=u[z],q=v[z]; if (dep[p]&gt;dep[q]) std::swap(p,q); //保证q为小子树子树的根 if (((G[q]&lt;=G[x]&amp;&amp;B[q]&gt;=G[x])&amp;&amp;(G[y]&lt;G[q]||B[y]&gt;B[q]))|| ((G[q]&lt;=G[y]&amp;&amp;B[q]&gt;=G[y])&amp;&amp;(G[x]&lt;G[q]||B[x]&gt;B[q]))) printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125; T3这题其实并不难，代码量也不大。但是思路比较难想。 很多人可能都会想树状数组、线段树能不能做（包括我这个蒟蒻）。 其实这题完全不用，用倍增就好了。 我们设$f[i][j]$为在$i$位置时，向后选$2^j$条线段所能达到的最小右端点$(Ri)$ 初始时，$f[i][0]$为以$i$为左端点$(Li)$的所有线段中取一个右端点最小的。（贪心法可证） 但我们在求解$f[i][j]$时要注意，由于线段不能重叠，所以说我们必须这样递推$f[i][j]=f[f[i][j−1]+1][j]$ 就是在跳小步的时候要$+1$。 然后还有在$i$比较大时，可能在$i$位置时，后面都没有线段，所以要特判掉。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define Re register intstruct Segment&#123; int l,r;&#125;d[100005];int N,Q,len,f[100005][18],p,q;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline bool cmp(Segment a,Segment b) &#123;return a.l&lt;b.l;&#125;int main(int argc, char const *argv[])&#123; read(N),read(Q),read(len); for (Re i=1; i&lt;=N; ++i) read(d[i].l),read(d[i].r); std::sort(d+1,d+N+1,cmp); int p=N,R=len+1; for (Re i=len; i&gt;0; --i) &#123; while (p&amp;&amp;d[p].l==i) R=std::min(R,d[p--].r); f[i][0]=R; &#125; for (Re j=1; j&lt;=17; ++j) for (Re i=1; i&lt;=len; ++i) if (f[i][j-1]!=len+1) f[i][j]=f[f[i][j-1]+1][j-1]; else f[i][j]=len+1; while (Q--) &#123; read(p),read(q); int ans=0; for (Re i=17; i&gt;=0; --i) if (f[p][i]&lt;=q) ans|=(1&lt;&lt;i),p=f[p][i]+1; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>SPFA</tag>
        <tag>2018国庆集训</tag>
        <tag>图的遍历</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国庆集训]Day2解题报告]]></title>
    <url>%2Farticles%2F%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD-Day2%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接戳我n(≧▽≦)n T1又是我在场上唯一A的一题。。。（话说的今天的题怎么比昨天难这么多啊！！！(#`O′)） 一看到这题首先想了一下线段树。emmm…好像没法做，看看了数据范围，$10^5$啊，肯定是$O(NlogN)$的算法。 于是我就很傻*的把所有$logN$的数据结构都想了一遍。 。 。 。 后来，我几乎想要放弃的时候，我盯住了一个$dalao$的脸，打量了许久后，看回屏幕，发现了重要关键字求最矮的花的最大高度，突然想到了$dalao$说过的经典语句像这种要求最小的最大值什么的，就用二分试试看。于是，我仔细考虑了一下，难点在于二分答案后怎么进行判断。 于是，我又再次盯住那个$dalao$的脸（事实证明$dalao$这题只有$50$），思考这种区间加的操作怎么快速实现。然后然后然后，就想到了差分约束。于是我大喊一声：“牛逼！”，然后开始光速敲代码。 快交卷的时候，教练说这是$CodeForces$上的原题，我顿时震惊(○´･д･)ﾉ。于是，光速打了个暴力，然后开始对拍（甚至还错了），事实证明我生成数据的时候居然生成了$L=0$的数据（我真是*了）。吓得我以为我错了。 。（讲点正经的↓↓↓） 由于高度单调，所以我们考虑二分答案，重要就在于怎么对答案进行判断。于是，我们对于二分出的高度$k$与花的高度$h[i]$进行逐一判断，如果一束花的高度小于$k$，那么，我们就必须让他长到$k$，但是我们是区间操作啊！所以考虑维护一个数组$s$进行差分，记录下当前的花已经长高了多少。这样我们可以逐一判断，就算有重合的区间操作也能够考虑完全。时间复杂度为$O(NlogN)$，就可以$A$掉这题了（不要像我这么傻*地去想数据结构）。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intint N,M,L,h[100005],s[100005],l,r,ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;bool Check(int k)&#123; int Day=M; for (Re i=1; i&lt;=N+1; ++i) s[i]=0; for (Re i=1; i&lt;=N; ++i) &#123; s[i]+=s[i-1]; if (s[i]+h[i]&lt;k) &#123; if (k-(s[i]+h[i])&gt;Day) return false; Day-=(k-(s[i]+h[i])); if (i+L&lt;=N) s[i+L]-=(k-(h[i]+s[i])); else s[N+1]-=(k-(h[i]+s[i])); s[i]+=(k-(h[i]+s[i])); &#125; &#125; return true;&#125;int main(int argc, char const *argv[])&#123; read(N),read(M),read(L); l=1; for (Re i=1; i&lt;=N; ++i) read(h[i]),r=std::max(r,h[i]); r+=M; while (l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if (Check(mid)) ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d\n",ans); return 0;&#125; T2这算是Day2里面最难的一题了，我一看到这题就printf(&quot;6\n9\n6\n&quot;);了（结果还有10分O(∩_∩)O） 考完后看了看官方题解 把删边操作倒过来，变成每次加边，维护直径有一个容易证明的结论两棵树合并后的直径，它的端点一定从这两棵树原本的直径中取那么预处理好最终树的形态，利用LCA和并查集就行了 说的实在是太好了（你TM还能再简单点吗？(╯▔皿▔)╯） 不过这里有个很重要的思路就是把删边操作倒过来（虽然我在考试的时候想过，但是还是不会。。。） 至于那个题解中的容易证明的结论 在下面我将给出证明 假设此树的最长路径是从s到t,我们选择的点为u。反证法：假设搜到的点是v。1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s]显然矛盾。2、v不在这条最长路径上，我们在最长路径上选择一个点为p，则dis[u,v]&gt;dis[u,p]+dis[p,t]，那么有dis[s,v]=dis[s,p]+dis[p,u]+dis[u,v]&gt;dis[s,p]+dis[p,t]=dis[s,t]，即dis[s,v]&gt;dis[s,t]矛盾。也许你想说u本身就在最长路径，或者其它的一些情况，但其实都能用类似于上面的反证法来证明的。综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路径长度。 所以说两棵树合并后的直径，它的端点一定从这两棵树原本的直径中取 那么如何计算答案呢？ 我们只需要对已经计算的$Ans$经行乘除操作就行，但是，可能会出现爆精度的情况。所以这个时候我们就需要用到逆元。至于什么是逆元，怎么求解逆元，则不再本题解的范围内。（如果想了解的请点我） 然后我们就可以大方的A掉这题了（再吐槽一下：你TM快100行的程序你题解就4行？？？）（我写的还算简短的了）（我们机房还有dalao写了180行！！） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MOD int(1e9+7)#define Re register int#define LL long longusing namespace std;struct Edge&#123; int to,next;&#125;e[200005];struct Point&#123; int u,v,w; inline bool operator &lt; (const Point &amp;a) const &#123;return w&gt;a.w;&#125;&#125;d[6];int cnt,head[100005],dx[100005],dy[100005],dz[100005],dis[100005],maxd;int N,w[100005],f[100005][18],u[100005],v[100005],k[100005],Fa[100005],dep[100005];LL Ans=1,ans[100005];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline void AddEdge(int u,int v)&#123; e[++cnt]=(Edge)&#123;v,head[u]&#125;; head[u]=cnt; e[++cnt]=(Edge)&#123;u,head[v]&#125;; head[v]=cnt;&#125;int GetF(int x) &#123;return x==Fa[x]?x:Fa[x]=GetF(Fa[x]);&#125;inline int KSM(int x,int y)&#123; int ret=1; while (y) &#123; if (y&amp;1) ret=ret*1LL*x%MOD; x=x*1LL*x%MOD; y&gt;&gt;=1; &#125; return ret;&#125;void LCA_dfs(int now,int fa)&#123; dep[now]=dep[fa]+1; dis[now]=dis[fa]+w[now]; f[now][0]=fa; maxd=max(maxd,dep[now]); for (Re i=head[now];i;i=e[i].next) if (e[i].to!=fa) LCA_dfs(e[i].to,now); return;&#125;inline int LCA(int u,int v)&#123; if (dep[u]&gt;dep[v]) swap(u,v); for (Re i=17; i&gt;=0; --i) if (dep[f[v][i]]&gt;=dep[u]) v=f[v][i]; for (Re i=17; i&gt;=0; --i) if (f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; return u==v?u:f[u][0];&#125;inline int Dist(int u,int v) &#123;return dis[u]+dis[v]-2*dis[LCA(u,v)]+w[LCA(u,v)];&#125; int main(int argc, char const *argv[])&#123; read(N); for (Re i=1; i&lt;=N; ++i) &#123; read(w[i]); dx[i]=dy[i]=Fa[i]=i; dis[i]=dz[i]=w[i]; Ans=Ans*w[i]%MOD; &#125; for (Re i=1; i&lt;N; ++i) read(u[i]),read(v[i]),AddEdge(u[i],v[i]); for (Re i=1; i&lt;N; ++i) read(k[i]); dep[1]=1; LCA_dfs(1,0); ans[N]=Ans; for (Re j=1; (1&lt;&lt;j)&lt;=maxd; ++j) for (Re i=1; i&lt;=N; ++i) f[i][j]=f[f[i][j-1]][j-1]; for (Re i=N-1; i&gt;=1; --i) &#123; int fx=GetF(u[k[i]]),fy=GetF(v[k[i]]); Fa[fx]=fy; Ans=Ans*KSM(dz[fx],MOD-2)%MOD*KSM(dz[fy],MOD-2)%MOD; d[0]=(Point)&#123;dx[fx],dy[fx],dz[fx]&#125;; d[1]=(Point)&#123;dx[fy],dy[fy],dz[fy]&#125;; d[2]=(Point)&#123;dx[fx],dx[fy],Dist(dx[fx],dx[fy])&#125;; d[3]=(Point)&#123;dx[fx],dy[fy],Dist(dx[fx],dy[fy])&#125;; d[4]=(Point)&#123;dy[fx],dx[fy],Dist(dy[fx],dx[fy])&#125;; d[5]=(Point)&#123;dy[fx],dy[fy],Dist(dy[fx],dy[fy])&#125;; sort(d,d+6); dx[fy]=d[0].u; dy[fy]=d[0].v; dz[fy]=d[0].w; Ans=Ans*dz[fy]%MOD; ans[i]=Ans; &#125; for (Re i=1; i&lt;=N; ++i) printf("%lld\n",ans[i]); return 0;&#125; T3这算是Day2中最简单的一题了（Guest：那你怎么没A？）（我：谁让他放最后一题？！高一蒟蒻不会数学期望啊，瑟瑟发抖） 不过教练前天晚上还给我们讲了期望，说明天会考（那就是我太菜了吧） 但是很多人都没有在现场A出来啊。。。看见题目中的与答案的差值&lt;=10^-5即视为正确。以为妥妥过了。 可是官方（线上测试）并没有写SPJ（官方说不会用）。。。 导致很多人AC的程序都被卡掉了。（心中窃喜） 不过后来想想，woc他们怎么都会，于是我打算好好学数学了……（过几天开坑写个数学笔记） 不扯淡了，看题解吧↓↓↓ 我们考虑设$f[i][j]$表示剩余$i$张红牌，剩余$j$张黑牌时的在最优策略下的期望收益。 很容易想到，$f[i][j]$肯定由$f[i−1][j],f[i][j−1]$转移而来。 同时，决策数量也很少，只有3种（别怪我，我不懂弄支持大括号） $f[i][j]=(f[i−1][j]+1)∗i/(i+j)$ $f[i][j]=(f[i][j−1]−1)∗j/(i+j)$ $f[i][j]=0$ 分别对应的是 抽到红牌 抽到黑牌 停止游戏 这样我们很容易写出状态转移方程 然后这里还可以使用滚动数组优化 程序不长，思路也挺简单的（但是我就是没A，看来要好好学数学了） 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intdouble f[2][1005];int N,M,p;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;int main(int argc, char const *argv[])&#123; read(N),read(M); for (Re i=1; i&lt;=N; ++i) &#123; p^=1; f[p][0]=i; for (Re j=1; j&lt;=M; ++j) f[p][j]=std::max(0.0,(f[p^1][j]+1)*i/double(i+j)+(f[p][j-1]-1)*j/double(i+j)); &#125; printf("%.8lf\n",f[p][M]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>LCA</tag>
        <tag>逆元</tag>
        <tag>2018国庆集训</tag>
        <tag>二分答案</tag>
        <tag>差分约束</tag>
        <tag>树的直径</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国庆集训]Day1解题报告]]></title>
    <url>%2Farticles%2F%E5%9B%BD%E5%BA%86%E9%9B%86%E8%AE%AD-Day1%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[题目链接戳我n(≧▽≦)n T1好吧这是我唯一在场A的题（,,ԾㅂԾ,,他们怎么都A了） 开始还想着打表。。。然后想想实际上这就是一个欧拉筛的模板啊，$O(N)$时间复杂度内能够筛出$1 \sim N$的素数，在筛除合数的过程中特判一下就可以求出$1 \sim 10^7$内的所有小W喜欢的数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register int#define MAX_X 10000000int Q,L,R,isPrime[MAX_X+1],Prime[2568904],Sum[MAX_X+1],len;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;void Euler_sieve()&#123; for (Re i=2; i&lt;=MAX_X; ++i) isPrime[i]=1; for (Re i=2; i&lt;=MAX_X; ++i) &#123; if (isPrime[i]) &#123; Prime[++len]=i; if (isPrime[i]==1) &#123; for (Re j=1; i*Prime[j]&lt;=MAX_X&amp;&amp;j&lt;=len; ++j) &#123; if (isPrime[Prime[j]]==2) continue; isPrime[i*Prime[j]]=2; if (i%Prime[j]==0) break; &#125; &#125; else for (Re j=1; i*Prime[j]&lt;=MAX_X&amp;&amp;j&lt;=len; ++j) &#123; isPrime[i*Prime[j]]=0; if (i%Prime[j]==0) break; &#125; &#125; else for (Re j=1; i*Prime[j]&lt;=MAX_X&amp;&amp;j&lt;=len; ++j) &#123; isPrime[i*Prime[j]]=0; if (i%Prime[j]==0) break; &#125; &#125; return;&#125;int main(int argc, char const *argv[])&#123; Euler_sieve(); for (Re i=1; i&lt;=MAX_X; ++i) if (isPrime[i]) Sum[i]=Sum[i-1]+1; else Sum[i]=Sum[i-1]; read(Q); while (Q--) &#123; read(L); read(R); printf("%d\n",Sum[R]-Sum[L-1]); &#125; return 0;&#125; T2emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm…………………………………………………………. 我居然天真的以为BFS过不了这题。。。一看到这题，还有$K \le 10$的范围。。。自然想到状压。 But我tm就是认为暴力过不了。。。（或许是看到了0.5s的时限。。。）太dog了(─.─|||。。。这里也不多做说明了。 状压+BFS妥妥过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;queue&gt;#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define Re register intusing namespace std;struct Edge&#123; int to,next,key;&#125;e[6005];int cnt,head[5005];int N,M,K,GetKey[5005],dis[5005][1024];template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline void AddEdge(int u,int v)&#123; int key=0; for (Re i=1,x; i&lt;=K; ++i) read(x),key&lt;&lt;=1,key|=x; e[++cnt]=(Edge)&#123;v,head[u],key&#125;; head[u]=cnt;&#125;void BFS()&#123; queue&lt; pair&lt;int,int&gt; &gt; q; q.push(make_pair(1,0)); dis[1][0]=1; while (!q.empty()) &#123; int now=q.front().first,nowkey=q.front().second,nw=nowkey; q.pop(); nowkey|=GetKey[now]; for (Re i=head[now];i;i=e[i].next) if ((e[i].key&amp;nowkey)==e[i].key&amp;&amp;!dis[e[i].to][nowkey]) if (e[i].to==N) &#123;printf("%d\n",dis[now][nw]); return;&#125; else q.push(make_pair(e[i].to,nowkey)),dis[e[i].to][nowkey]=dis[now][nw]+1; &#125; printf("No Solution\n"); return;&#125;int main(int argc, char const *argv[])&#123; read(N),read(M),read(K); for (Re i=1,x; i&lt;=N; ++i) for (Re j=1; j&lt;=K; ++j) read(x),GetKey[i]&lt;&lt;=1,GetKey[i]|=x; for (Re i=1,u,v; i&lt;=M; ++i) read(u),read(v),AddEdge(u,v); BFS(); return 0;&#125; T3很裸的LCA，借这个机会复习一下LCA。 给一个LCA的模板吧，博主自己写的哦~~~ヾ(·∀·o)+ 1234567891011121314151617181920212223void dfs(int now,int fa)&#123; f[now][0]=fa; d[now]=d[fa]+1; maxd=max(maxd,d[now]); for (Re i=head[now];i;i=e[i].next) if (e[i].to!=fa) dfs(e[i].to,now);&#125;int LCA(int u,int v) //写了很多种LCA的版本，还是觉得这个比较好&#123; if (d[u]&gt;d[v]) swap(u,v); for (int i=20; i&gt;=0; --i) if (d[f[v][i]]&gt;=d[u]) v=f[v][i]; for (int i=20; i&gt;=0; --i) if (f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; if (u==v) return u; else return f[u][0]; //至于为什么会存在u==v，是存在LCA(u,v)=u或者v的情况&#125;void Initialization()&#123; dfs(1,0); for (int j=1; (1&lt;&lt;j)&lt;=maxd; ++j) //maxd为树的最大深度 for (int i=1; i&lt;=N; ++i) f[i][j]=f[f[i][j-1]][j-1];&#125; 对于这道题目，其实只需要求两条路径重合部分的长度就好了 所以我就不多进行解释，放代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;iostream&gt;#define Re register intstruct Edge&#123; int to,next;&#125;e[400005];int cnt,head[200005];int N,Q,NUM,maxd,d[200005],f[200005][21],ans;template &lt;typename T&gt; inline void read(T &amp;var)&#123; T x=0; int w=0; char ch=0; while (!isdigit(ch)) w|=ch=='-',ch=getchar(); while (isdigit(ch)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); var=w?-x:x;&#125;inline void AddEdge(int u,int v) &#123;e[++cnt]=(Edge)&#123;v,head[u]&#125;; head[u]=cnt;&#125;void dfs(int now,int fa)&#123; f[now][0]=fa; d[now]=d[fa]+1; maxd=std::max(maxd,d[now]); for (Re i=head[now];i;i=e[i].next) if (e[i].to!=fa) dfs(e[i].to,now);&#125;int LCA(int u,int v)&#123; if (d[u]&gt;d[v]) std::swap(u,v); for (int i=20; i&gt;=0; --i) if (d[f[v][i]]&gt;=d[u]) v=f[v][i]; for (int i=20; i&gt;=0; --i) if (f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; if (u==v) return u; else return f[u][0];&#125;int dist(int u,int v) &#123;return d[u]+d[v]-2*d[LCA(u,v)];&#125;int main(int argc, char const *argv[])&#123; read(N),read(Q),read(NUM); for (Re i=1,u,v; i&lt;N; ++i) read(u),read(v),AddEdge(u,v),AddEdge(v,u); dfs(1,0); for (Re j=1; (1&lt;&lt;j)&lt;=maxd; ++j) for (Re i=1; i&lt;=N; ++i) f[i][j]=f[f[i][j-1]][j-1]; for (Re i=1,A,B,C; i&lt;=Q; ++i) &#123; read(A),read(B),read(C); printf("%d\n",(dist(A,B)+dist(C,B)-dist(A,C))/2+1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>LCA</tag>
        <tag>2018国庆集训</tag>
        <tag>欧拉筛</tag>
        <tag>BFS</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博声明]]></title>
    <url>%2Farticles%2F%E5%BC%80%E5%8D%9A%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[马上就要NOIP2018了，感觉自己什么都不会。。。（只会瞎搞搞）所以，想来想去还是开一个博客吧。写写题解、笔记什么的，还能加深自己对知识的印象，感觉好麻烦不错。所以特地开了一个github的博客。（PS：这博客怎么这么麻烦） 博主QQ:1297977829 还可以加个Q群：320599316]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
